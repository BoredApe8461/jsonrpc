var searchIndex = {};
searchIndex["jsonrpc_core"] = {"doc":"Transport agnostic jsonrpc library.","items":[[3,"IoHandler","jsonrpc_core","Simplified `IoHandler` with no `Metadata` associated with each request.",null,null],[3,"MetaIoHandler","","Request handler",null,null],[3,"NoopMiddleware","","No-op middleware implementation",null,null],[4,"RemoteProcedure","","Possible Remote Procedures with Metadata",null,null],[13,"Method","","A method call",0,null],[13,"Notification","","A notification",0,null],[13,"Alias","","An alias to other method,",0,null],[4,"Compatibility","","`IoHandler` json-rpc protocol compatibility",null,null],[13,"V1","","Compatible only with JSON-RPC 1.x",1,null],[13,"V2","","Compatible only with JSON-RPC 2.0",1,null],[13,"Both","","Compatible with both",1,null],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"remoteprocedure"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"compatibility"}}],[11,"default","","",1,{"o":{"n":"self"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",2,{"o":{"n":"self"}}],[11,"with_compatibility","","Creates new `MetaIoHandler` compatible with specified protocol version.",2,{"i":[{"n":"compatibility"}],"o":{"n":"self"}}],[11,"new","","Creates new `MetaIoHandler`",2,{"i":[{"n":"compatibility"},{"n":"s"}],"o":{"n":"self"}}],[11,"with_middleware","","Creates new `MetaIoHandler` with specified middleware.",2,{"i":[{"n":"s"}],"o":{"n":"self"}}],[11,"add_alias","","Adds an alias to a method.",2,{"i":[{"n":"self"},{"n":"str"},{"n":"str"}]}],[11,"add_method","","Adds new supported asynchronous method",2,{"i":[{"n":"self"},{"n":"str"},{"n":"f"}]}],[11,"add_notification","","Adds new supported notification",2,{"i":[{"n":"self"},{"n":"str"},{"n":"f"}]}],[11,"add_method_with_meta","","Adds new supported asynchronous method with metadata support.",2,{"i":[{"n":"self"},{"n":"str"},{"n":"f"}]}],[11,"add_notification_with_meta","","Adds new supported notification with metadata support.",2,{"i":[{"n":"self"},{"n":"str"},{"n":"f"}]}],[11,"extend_with","","Extend this `MetaIoHandler` with methods defined elsewhere.",2,{"i":[{"n":"self"},{"n":"f"}]}],[11,"handle_request_sync","","Handle given request synchronously - will block until response is available. If you have any asynchronous methods in your RPC it is much wiser to use `handle_request` instead and deal with asynchronous requests in a non-blocking fashion.",2,{"i":[{"n":"self"},{"n":"str"},{"n":"t"}],"o":{"g":["string"],"n":"option"}}],[11,"handle_request","","Handle given request asynchronously.",2,{"i":[{"n":"self"},{"n":"str"},{"n":"t"}],"o":{"n":"futureresult"}}],[11,"handle_rpc_request","","Handle deserialized RPC request.",2,null],[11,"handle_call","","Handle single call asynchronously.",2,{"i":[{"n":"self"},{"n":"call"},{"n":"t"}],"o":{"g":["box","futureresult"],"n":"either"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",3,{"o":{"n":"iohandler"}}],[11,"new","","Creates new `IoHandler` without any metadata.",3,{"o":{"n":"self"}}],[11,"with_compatibility","","Creates new `IoHandler` without any metadata compatible with specified protocol version.",3,{"i":[{"n":"compatibility"}],"o":{"n":"self"}}],[11,"handle_request","","Handle given string request asynchronously.",3,{"i":[{"n":"self"},{"n":"str"}],"o":{"g":["futureresponse"],"n":"futureresult"}}],[11,"handle_rpc_request","","Handle deserialized RPC request asynchronously.",3,{"i":[{"n":"self"},{"n":"request"}],"o":{"n":"futureresponse"}}],[11,"handle_call","","Handle single Call asynchronously.",3,{"i":[{"n":"self"},{"n":"call"}],"o":{"g":["box","futureresult"],"n":"either"}}],[11,"handle_request_sync","","Handle given request synchronously - will block until response is available. If you have any asynchronous methods in your RPC it is much wiser to use `handle_request` instead and deal with asynchronous requests in a non-blocking fashion.",3,{"i":[{"n":"self"},{"n":"str"}],"o":{"g":["string"],"n":"option"}}],[11,"deref","","",3,null],[11,"deref_mut","","",3,null],[11,"from","","",2,{"i":[{"n":"iohandler"}],"o":{"n":"self"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",4,{"o":{"n":"noop"}}],[11,"on_request","","",4,null],[0,"types","","JSON-RPC types",null,null],[4,"Value","jsonrpc_core::types","Represents any valid JSON value.",null,null],[13,"Null","","Represents a JSON null value.",5,null],[13,"Bool","","Represents a JSON boolean.",5,null],[13,"Number","","Represents a JSON number, whether integer or floating point.",5,null],[13,"String","","Represents a JSON string.",5,null],[13,"Array","","Represents a JSON array.",5,null],[13,"Object","","Represents a JSON object.",5,null],[5,"to_value","","Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.",null,{"i":[{"n":"t"}],"o":{"g":["value","error"],"n":"result"}}],[5,"to_string","","Serialize the given data structure as a String of JSON.",null,{"i":[{"n":"t"}],"o":{"g":["string","error"],"n":"result"}}],[0,"error","","jsonrpc errors",null,null],[3,"Error","jsonrpc_core::types::error","Error object as defined in Spec",null,null],[12,"code","","Code",6,null],[12,"message","","Message",6,null],[12,"data","","Optional data",6,null],[4,"ErrorCode","","JSONRPC error code",null,null],[13,"ParseError","","Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",7,null],[13,"InvalidRequest","","The JSON sent is not a valid Request object.",7,null],[13,"MethodNotFound","","The method does not exist / is not available.",7,null],[13,"InvalidParams","","Invalid method parameter(s).",7,null],[13,"InternalError","","Internal JSON-RPC error.",7,null],[13,"ServerError","","Reserved for implementation-defined server-errors.",7,null],[11,"fmt","","",7,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",7,{"i":[{"n":"self"},{"n":"errorcode"}],"o":{"n":"bool"}}],[11,"ne","","",7,{"i":[{"n":"self"},{"n":"errorcode"}],"o":{"n":"bool"}}],[11,"clone","","",7,{"i":[{"n":"self"}],"o":{"n":"errorcode"}}],[11,"code","","Returns integer code value",7,{"i":[{"n":"self"}],"o":{"n":"i64"}}],[11,"description","","Returns human-readable description",7,{"i":[{"n":"self"}],"o":{"n":"string"}}],[11,"from","","",7,{"i":[{"n":"i64"}],"o":{"n":"self"}}],[11,"deserialize","","",7,{"i":[{"n":"d"}],"o":{"g":["errorcode"],"n":"result"}}],[11,"serialize","","",7,{"i":[{"n":"self"},{"n":"s"}],"o":{"n":"result"}}],[11,"fmt","","",6,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",6,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"ne","","",6,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"bool"}}],[11,"clone","","",6,{"i":[{"n":"self"}],"o":{"n":"error"}}],[11,"new","","Wraps given `ErrorCode`",6,{"i":[{"n":"errorcode"}],"o":{"n":"self"}}],[11,"parse_error","","Creates new `ParseError`",6,{"o":{"n":"self"}}],[11,"invalid_request","","Creates new `InvalidRequest`",6,{"o":{"n":"self"}}],[11,"method_not_found","","Creates new `MethodNotFound`",6,{"o":{"n":"self"}}],[11,"invalid_params","","Creates new `InvalidParams`",6,{"i":[{"n":"m"}],"o":{"n":"self"}}],[11,"internal_error","","Creates new `InternalError`",6,{"o":{"n":"self"}}],[11,"invalid_version","","Creates new `InvalidRequest` with invalid version description",6,{"o":{"n":"self"}}],[0,"id","jsonrpc_core::types","jsonrpc id field",null,null],[4,"Id","jsonrpc_core::types::id","Request Id",null,null],[13,"Null","","No id (notification)",8,null],[13,"Num","","Numeric id",8,null],[13,"Str","","String id",8,null],[11,"fmt","","",8,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",8,{"i":[{"n":"self"},{"n":"id"}],"o":{"n":"bool"}}],[11,"ne","","",8,{"i":[{"n":"self"},{"n":"id"}],"o":{"n":"bool"}}],[11,"clone","","",8,{"i":[{"n":"self"}],"o":{"n":"id"}}],[11,"hash","","",8,null],[0,"params","jsonrpc_core::types","jsonrpc params field",null,null],[4,"Params","jsonrpc_core::types::params","Request parameters",null,null],[13,"None","","No parameters",9,null],[13,"Array","","Array of values",9,null],[13,"Map","","Map of values",9,null],[11,"fmt","","",9,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",9,{"i":[{"n":"self"},{"n":"params"}],"o":{"n":"bool"}}],[11,"ne","","",9,{"i":[{"n":"self"},{"n":"params"}],"o":{"n":"bool"}}],[11,"clone","","",9,{"i":[{"n":"self"}],"o":{"n":"params"}}],[11,"parse","","Parse incoming `Params` into expected types.",9,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[0,"request","jsonrpc_core::types","jsonrpc request",null,null],[3,"MethodCall","jsonrpc_core::types::request","Represents jsonrpc request which is a method call.",null,null],[12,"jsonrpc","","A String specifying the version of the JSON-RPC protocol.",10,null],[12,"method","","A String containing the name of the method to be invoked.",10,null],[12,"params","","A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted.",10,null],[12,"id","","An identifier established by the Client that MUST contain a String, Number, or NULL value if included. If it is not included it is assumed to be a notification.",10,null],[3,"Notification","","Represents jsonrpc request which is a notification.",null,null],[12,"jsonrpc","","A String specifying the version of the JSON-RPC protocol.",11,null],[12,"method","","A String containing the name of the method to be invoked.",11,null],[12,"params","","A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted.",11,null],[4,"Call","","Represents single jsonrpc call.",null,null],[13,"MethodCall","","Call method",12,null],[13,"Notification","","Fire notification",12,null],[13,"Invalid","","Invalid call",12,null],[12,"id","jsonrpc_core::types::request::Call","Call id (if known)",12,null],[4,"Request","jsonrpc_core::types::request","Represents jsonrpc request.",null,null],[13,"Single","","Single request (call)",13,null],[13,"Batch","","Batch of requests (calls)",13,null],[11,"fmt","","",10,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",10,{"i":[{"n":"self"},{"n":"methodcall"}],"o":{"n":"bool"}}],[11,"ne","","",10,{"i":[{"n":"self"},{"n":"methodcall"}],"o":{"n":"bool"}}],[11,"fmt","","",11,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",11,{"i":[{"n":"self"},{"n":"notification"}],"o":{"n":"bool"}}],[11,"ne","","",11,{"i":[{"n":"self"},{"n":"notification"}],"o":{"n":"bool"}}],[11,"fmt","","",12,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",12,{"i":[{"n":"self"},{"n":"call"}],"o":{"n":"bool"}}],[11,"ne","","",12,{"i":[{"n":"self"},{"n":"call"}],"o":{"n":"bool"}}],[11,"from","","",12,{"i":[{"n":"methodcall"}],"o":{"n":"self"}}],[11,"from","","",12,{"i":[{"n":"notification"}],"o":{"n":"self"}}],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",13,{"i":[{"n":"self"},{"n":"request"}],"o":{"n":"bool"}}],[11,"ne","","",13,{"i":[{"n":"self"},{"n":"request"}],"o":{"n":"bool"}}],[0,"response","jsonrpc_core::types","jsonrpc response",null,null],[3,"Success","jsonrpc_core::types::response","Successful response",null,null],[12,"jsonrpc","","Protocol version",14,null],[12,"result","","Result",14,null],[12,"id","","Correlation id",14,null],[3,"Failure","","Unsuccessful response",null,null],[12,"jsonrpc","","Protocol Version",15,null],[12,"error","","Error",15,null],[12,"id","","Correlation id",15,null],[4,"Output","","Represents output - failure or success",null,null],[13,"Success","","Success",16,null],[13,"Failure","","Failure",16,null],[4,"Response","","Synchronous response",null,null],[13,"Single","","Single response",17,null],[13,"Batch","","Response to batch request (batch of responses)",17,null],[11,"fmt","","",14,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",14,{"i":[{"n":"self"},{"n":"success"}],"o":{"n":"bool"}}],[11,"ne","","",14,{"i":[{"n":"self"},{"n":"success"}],"o":{"n":"bool"}}],[11,"clone","","",14,{"i":[{"n":"self"}],"o":{"n":"success"}}],[11,"fmt","","",15,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",15,{"i":[{"n":"self"},{"n":"failure"}],"o":{"n":"bool"}}],[11,"ne","","",15,{"i":[{"n":"self"},{"n":"failure"}],"o":{"n":"bool"}}],[11,"clone","","",15,{"i":[{"n":"self"}],"o":{"n":"failure"}}],[11,"fmt","","",16,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",16,{"i":[{"n":"self"},{"n":"output"}],"o":{"n":"bool"}}],[11,"ne","","",16,{"i":[{"n":"self"},{"n":"output"}],"o":{"n":"bool"}}],[11,"clone","","",16,{"i":[{"n":"self"}],"o":{"n":"output"}}],[11,"from","","Creates new output given `Result`, `Id` and `Version`.",16,{"i":[{"g":["value"],"n":"coreresult"},{"n":"id"},{"g":["version"],"n":"option"}],"o":{"n":"self"}}],[11,"invalid_request","","Creates new failure output indicating malformed request.",16,{"i":[{"n":"id"},{"g":["version"],"n":"option"}],"o":{"n":"self"}}],[11,"version","","Get the jsonrpc protocol version.",16,{"i":[{"n":"self"}],"o":{"g":["version"],"n":"option"}}],[11,"id","","Get the correlation id.",16,{"i":[{"n":"self"}],"o":{"n":"id"}}],[11,"fmt","","",17,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",17,{"i":[{"n":"self"},{"n":"response"}],"o":{"n":"bool"}}],[11,"ne","","",17,{"i":[{"n":"self"},{"n":"response"}],"o":{"n":"bool"}}],[11,"from","","Creates new `Response` with given error and `Version`",17,{"i":[{"n":"error"},{"g":["version"],"n":"option"}],"o":{"n":"self"}}],[11,"from","","",17,{"i":[{"n":"failure"}],"o":{"n":"self"}}],[11,"from","","",17,{"i":[{"n":"success"}],"o":{"n":"self"}}],[0,"version","jsonrpc_core::types","jsonrpc version field",null,null],[4,"Version","jsonrpc_core::types::version","Protocol Version",null,null],[13,"V2","","JSONRPC 2.0",18,null],[11,"fmt","","",18,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",18,{"i":[{"n":"self"},{"n":"version"}],"o":{"n":"bool"}}],[11,"clone","","",18,{"i":[{"n":"self"}],"o":{"n":"version"}}],[11,"hash","","",18,null],[11,"serialize","","",18,{"i":[{"n":"self"},{"n":"s"}],"o":{"n":"result"}}],[11,"deserialize","","",18,{"i":[{"n":"d"}],"o":{"g":["version"],"n":"result"}}],[6,"BoxFuture","jsonrpc_core","A `Future` trait object.",null,null],[6,"Result","","A Result type.",null,null],[6,"FutureResponse","","A type representing middleware or RPC response before serialization.",null,null],[6,"FutureResult","","A type representing future string response.",null,null],[8,"Metadata","","Metadata trait",null,null],[8,"RpcMethodSimple","","Asynchronous Method",null,null],[16,"Out","","Output future",19,null],[10,"call","","Call method",19,null],[8,"RpcMethod","","Asynchronous Method with Metadata",null,null],[10,"call","","Call method",20,{"i":[{"n":"self"},{"n":"params"},{"n":"t"}],"o":{"g":["value"],"n":"boxfuture"}}],[8,"RpcNotificationSimple","","Notification",null,null],[10,"execute","","Execute notification",21,{"i":[{"n":"self"},{"n":"params"}]}],[8,"RpcNotification","","Notification with Metadata",null,null],[10,"execute","","Execute notification",22,{"i":[{"n":"self"},{"n":"params"},{"n":"t"}]}],[8,"Middleware","","RPC middleware",null,null],[16,"Future","","A returned future.",23,null],[10,"on_request","","Method invoked on each request. Allows you to either respond directly (without executing RPC call) or do any additional work before and/or after processing the request.",23,null],[11,"get","jsonrpc_core::types","Index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",5,{"i":[{"n":"self"},{"n":"i"}],"o":{"g":["value"],"n":"option"}}],[11,"get_mut","","Mutably index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",5,{"i":[{"n":"self"},{"n":"i"}],"o":{"g":["value"],"n":"option"}}],[11,"is_object","","Returns true if the `Value` is an Object. Returns false otherwise.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"as_object","","If the `Value` is an Object, returns the associated Map. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["map"],"n":"option"}}],[11,"as_object_mut","","If the `Value` is an Object, returns the associated mutable Map. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["map"],"n":"option"}}],[11,"is_array","","Returns true if the `Value` is an Array. Returns false otherwise.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"as_array","","If the `Value` is an Array, returns the associated vector. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["vec"],"n":"option"}}],[11,"as_array_mut","","If the `Value` is an Array, returns the associated mutable vector. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["vec"],"n":"option"}}],[11,"is_string","","Returns true if the `Value` is a String. Returns false otherwise.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"as_str","","If the `Value` is a String, returns the associated str. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["str"],"n":"option"}}],[11,"is_number","","Returns true if the `Value` is a Number. Returns false otherwise.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"is_i64","","Returns true if the `Value` is an integer between `i64::MIN` and `i64::MAX`.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"is_u64","","Returns true if the `Value` is an integer between zero and `u64::MAX`.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"is_f64","","Returns true if the `Value` is a number that can be represented by f64.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"as_i64","","If the `Value` is an integer, represent it as i64 if possible. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["i64"],"n":"option"}}],[11,"as_u64","","If the `Value` is an integer, represent it as u64 if possible. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["u64"],"n":"option"}}],[11,"as_f64","","If the `Value` is a number, represent it as f64 if possible. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["f64"],"n":"option"}}],[11,"is_boolean","","Returns true if the `Value` is a Boolean. Returns false otherwise.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"as_bool","","If the `Value` is a Boolean, returns the associated bool. Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"g":["bool"],"n":"option"}}],[11,"is_null","","Returns true if the `Value` is a Null. Returns false otherwise.",5,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"as_null","","If the `Value` is a Null, returns (). Returns None otherwise.",5,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"pointer","","Looks up a value by a JSON Pointer.",5,{"i":[{"n":"self"},{"n":"str"}],"o":{"g":["value"],"n":"option"}}],[11,"pointer_mut","","Looks up a value by a JSON Pointer and returns a mutable reference to that value.",5,{"i":[{"n":"self"},{"n":"str"}],"o":{"g":["value"],"n":"option"}}],[11,"take","","Takes the value out of the `Value`, leaving a `Null` in its place.",5,{"i":[{"n":"self"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"i64"}],"o":{"n":"value"}}],[11,"from","","Convert 32-bit floating point number to `Value`",5,{"i":[{"n":"f32"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"usize"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"i8"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"u8"}],"o":{"n":"value"}}],[11,"from","","Convert string slice to `Value`",5,{"i":[{"n":"str"}],"o":{"n":"value"}}],[11,"from","","Convert a slice to `Value`",5,null],[11,"from","","Convert boolean to `Value`",5,{"i":[{"n":"bool"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"u32"}],"o":{"n":"value"}}],[11,"from","","Convert 64-bit floating point number to `Value`",5,{"i":[{"n":"f64"}],"o":{"n":"value"}}],[11,"from","","Convert `String` to `Value`",5,{"i":[{"n":"string"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"i16"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"u16"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"i32"}],"o":{"n":"value"}}],[11,"from","","Convert map (with string keys) to `Value`",5,{"i":[{"g":["string","value"],"n":"map"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"u64"}],"o":{"n":"value"}}],[11,"from","","Convert a `Vec` to `Value`",5,{"i":[{"n":"vec"}],"o":{"n":"value"}}],[11,"from","","",5,{"i":[{"n":"isize"}],"o":{"n":"value"}}],[11,"from","","Convert copy-on-write string to `Value`",5,{"i":[{"g":["str"],"n":"cow"}],"o":{"n":"value"}}],[11,"fmt","","Display a JSON value as a string.",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"i64"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"u8"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"f64"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"value"}],"o":{"n":"bool"}}],[11,"ne","","",5,{"i":[{"n":"self"},{"n":"value"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"u64"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"bool"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"i32"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"f32"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"string"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"str"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"str"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"u16"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"i16"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"isize"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"i8"}],"o":{"n":"bool"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"u32"}],"o":{"n":"bool"}}],[11,"clone","","",5,{"i":[{"n":"self"}],"o":{"n":"value"}}],[11,"index","","Index into a `serde_json::Value` using the syntax `value[0]` or `value[\"k\"]`.",5,{"i":[{"n":"self"},{"n":"i"}],"o":{"n":"value"}}],[11,"from_str","","",5,{"i":[{"n":"str"}],"o":{"g":["value","error"],"n":"result"}}],[11,"from_iter","","Convert an iteratable type to a `Value`",5,{"i":[{"n":"i"}],"o":{"n":"value"}}],[11,"default","","",5,{"o":{"n":"value"}}],[11,"deserialize_any","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_i8","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_i16","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_i32","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_i64","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_u8","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_u16","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_u32","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_u64","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_f32","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_f64","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_i128","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_u128","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_option","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"g":["error"],"n":"result"}}],[11,"deserialize_enum","","",5,null],[11,"deserialize_newtype_struct","","",5,{"i":[{"n":"self"},{"n":"str"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_bool","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_char","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_str","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_string","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_bytes","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_byte_buf","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_unit","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_unit_struct","","",5,{"i":[{"n":"self"},{"n":"str"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_seq","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_tuple","","",5,{"i":[{"n":"self"},{"n":"usize"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_tuple_struct","","",5,{"i":[{"n":"self"},{"n":"str"},{"n":"usize"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_map","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_struct","","",5,null],[11,"deserialize_identifier","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"deserialize_ignored_any","","",5,{"i":[{"n":"self"},{"n":"v"}],"o":{"n":"result"}}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"serialize","","",5,{"i":[{"n":"self"},{"n":"s"}],"o":{"n":"result"}}],[11,"deserialize","","",5,{"i":[{"n":"d"}],"o":{"g":["value"],"n":"result"}}],[11,"index_mut","","Write into a `serde_json::Value` using the syntax `value[0] = ...` or `value[\"k\"] = ...`.",5,{"i":[{"n":"self"},{"n":"i"}],"o":{"n":"value"}}],[11,"from","jsonrpc_core","Convert into a result. Will be `Ok` if it is a `Success` and `Err` if `Failure`.",24,{"i":[{"n":"output"}],"o":{"g":["value"],"n":"coreresult"}}]],"paths":[[4,"RemoteProcedure"],[4,"Compatibility"],[3,"MetaIoHandler"],[3,"IoHandler"],[3,"NoopMiddleware"],[4,"Value"],[3,"Error"],[4,"ErrorCode"],[4,"Id"],[4,"Params"],[3,"MethodCall"],[3,"Notification"],[4,"Call"],[4,"Request"],[3,"Success"],[3,"Failure"],[4,"Output"],[4,"Response"],[4,"Version"],[8,"RpcMethodSimple"],[8,"RpcMethod"],[8,"RpcNotificationSimple"],[8,"RpcNotification"],[8,"Middleware"],[6,"Result"]]};
searchIndex["jsonrpc_http_server"] = {"doc":"jsonrpc http server.","items":[[3,"Host","jsonrpc_http_server","Host type",null,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",0,null],[13,"Disabled","","Disable domains validation completely.",0,null],[4,"AccessControlAllowOrigin","","Origins allowed to access",null,null],[13,"Value","","Specific hostname",1,null],[13,"Null","","null-origin (file:///, sandboxed iframe)",1,null],[13,"Any","","Any non-null origin",1,null],[3,"Origin","","Request Origin",null,null],[0,"net","jsonrpc_http_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[3,"UdpFramed","jsonrpc_http_server::tokio_core::net","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[8,"UdpCodec","","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",2,null],[16,"Out","","The type of frames to be encoded.",2,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",2,null],[10,"encode","","Encodes a frame into the buffer provided.",2,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[0,"reactor","jsonrpc_http_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_http_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[4,"CorsHeader","jsonrpc_http_server","CORS Header Result.",null,null],[13,"NotRequired","","CORS header was not required. Origin is not present in the request.",3,null],[13,"Invalid","","CORS header is not returned, Origin is not allowed to access the resource.",3,null],[13,"Ok","","CORS header to include in the response. Origin is allowed to access the resource.",3,null],[3,"ServerHandler","","jsonrpc http request handler.",null,null],[3,"Response","","Simple server response structure",null,null],[12,"code","","Response code",4,null],[12,"content_type","","Response content type",4,null],[12,"content","","Response body",4,null],[3,"Rpc","","RPC Handler bundled with metadata extractor.",null,null],[12,"handler","","RPC Handler",5,null],[12,"extractor","","Metadata extractor",5,null],[3,"ServerBuilder","","Convenient JSON-RPC HTTP Server builder.",null,null],[3,"Server","","jsonrpc http server instance",null,null],[4,"RequestMiddlewareAction","","Action undertaken by a middleware.",null,null],[13,"Proceed","","Proceed with standard RPC handling",6,null],[12,"should_continue_on_invalid_cors","jsonrpc_http_server::RequestMiddlewareAction","Should the request be processed even if invalid CORS headers are detected? This allows for side effects to take place.",6,null],[12,"request","","The request object returned",6,null],[13,"Respond","jsonrpc_http_server","Intercept the request and respond differently.",6,null],[12,"should_validate_hosts","jsonrpc_http_server::RequestMiddlewareAction","Should standard hosts validation be performed?",6,null],[12,"response","","a future for server response",6,null],[4,"RestApi","jsonrpc_http_server","REST -> RPC converter state.",null,null],[13,"Secure","","The REST -> RPC converter is enabled and requires `Content-Type: application/json` header (even though the body should be empty). This protects from submitting an RPC call from unwanted origins.",7,null],[13,"Unsecure","","The REST -> RPC converter is enabled and does not require any `Content-Type` headers. NOTE: This allows sending RPCs via HTTP forms from any website.",7,null],[13,"Disabled","","The REST -> RPC converter is disabled.",7,null],[5,"is_host_allowed","","Returns `true` if Host header in request matches a list of allowed hosts.",null,{"i":[{"n":"request"},{"n":"option"}],"o":{"n":"bool"}}],[5,"cors_header","","Returns a CORS header that should be returned with that request.",null,{"i":[{"n":"request"},{"n":"option"}],"o":{"g":["accesscontrolalloworigin"],"n":"corsheader"}}],[11,"new","","Create new request handler.",8,{"i":[{"n":"rpc"},{"g":["vec"],"n":"option"},{"g":["u32"],"n":"option"},{"g":["vec"],"n":"option"},{"g":["requestmiddleware"],"n":"arc"},{"n":"restapi"},{"n":"usize"}],"o":{"n":"self"}}],[11,"call","","",8,null],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"empty","","Create a response with empty body and 200 OK status code.",4,{"o":{"n":"self"}}],[11,"ok","","Create a response with given body and 200 OK status code.",4,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"internal_error","","Create a response for internal error.",4,{"o":{"n":"self"}}],[11,"host_not_allowed","","Create a response for not allowed hosts.",4,{"o":{"n":"self"}}],[11,"unsupported_content_type","","Create a response for unsupported content type.",4,{"o":{"n":"self"}}],[11,"method_not_allowed","","Create a response for disallowed method used.",4,{"o":{"n":"self"}}],[11,"invalid_cors","","CORS invalid",4,{"o":{"n":"self"}}],[11,"bad_request","","Create a response for bad request",4,{"i":[{"n":"s"}],"o":{"n":"self"}}],[11,"too_large","","Create a response for too large (413)",4,{"i":[{"n":"s"}],"o":{"n":"self"}}],[11,"into","","",4,{"i":[{"n":"self"}],"o":{"n":"response"}}],[8,"RequestMiddleware","","Allows to intercept request and handle it differently.",null,null],[10,"on_request","","Takes a request and decides how to proceed with it.",9,{"i":[{"n":"self"},{"n":"request"}],"o":{"n":"requestmiddlewareaction"}}],[8,"MetaExtractor","","Extracts metadata from the HTTP request.",null,null],[10,"read_metadata","","Read the metadata from the request",10,{"i":[{"n":"self"},{"n":"request"}],"o":{"n":"m"}}],[11,"from","","",6,{"i":[{"n":"response"}],"o":{"n":"self"}}],[11,"from","","",6,{"i":[{"n":"response"}],"o":{"n":"self"}}],[11,"from","","",6,{"i":[{"n":"request"}],"o":{"n":"self"}}],[11,"clone","","",5,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"fmt","","",7,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",7,{"i":[{"n":"self"},{"n":"restapi"}],"o":{"n":"bool"}}],[11,"clone","","",7,{"i":[{"n":"self"}],"o":{"n":"restapi"}}],[11,"new","","Creates new `ServerBuilder` for given `IoHandler`.",11,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"with_meta_extractor","","Creates new `ServerBuilder` for given `IoHandler`.",11,{"i":[{"n":"t"},{"n":"e"}],"o":{"n":"self"}}],[11,"event_loop_remote","","Utilize existing event loop remote to poll RPC results.",11,{"i":[{"n":"self"},{"n":"remote"}],"o":{"n":"self"}}],[11,"rest_api","","Enable the REST -> RPC converter.",11,{"i":[{"n":"self"},{"n":"restapi"}],"o":{"n":"self"}}],[11,"keep_alive","","Sets Enables or disables HTTP keep-alive.",11,{"i":[{"n":"self"},{"n":"bool"}],"o":{"n":"self"}}],[11,"threads","","Sets number of threads of the server to run.",11,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"self"}}],[11,"cors","","Configures a list of allowed CORS origins.",11,{"i":[{"n":"self"},{"g":["accesscontrolalloworigin"],"n":"domainsvalidation"}],"o":{"n":"self"}}],[11,"cors_max_age","","Configure CORS `AccessControlMaxAge` header returned.",11,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"request_middleware","","Configures request middleware",11,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"meta_extractor","","Configures metadata extractor",11,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"allow_only_bind_host","","Allow connections only with `Host` header set to binding address.",11,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"allowed_hosts","","Specify a list of valid `Host` headers. Binding address is allowed automatically.",11,{"i":[{"n":"self"},{"g":["host"],"n":"domainsvalidation"}],"o":{"n":"self"}}],[11,"max_request_body_size","","Sets the maximum size of a request body in bytes (default is 5 MiB).",11,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"self"}}],[11,"start_http","","Start this JSON-RPC HTTP server trying to bind to specified `SocketAddr`.",11,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["server"],"n":"result"}}],[11,"address","","Returns address of this server",12,{"i":[{"n":"self"}],"o":{"n":"socketaddr"}}],[11,"close","","Closes the server.",12,{"i":[{"n":"self"}]}],[11,"wait","","Will block, waiting for the server to finish.",12,{"i":[{"n":"self"}]}],[11,"drop","","",12,{"i":[{"n":"self"}]}],[11,"new","","Creates a new `Host` given hostname and port number.",13,{"i":[{"n":"str"},{"n":"t"}],"o":{"n":"host"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",13,{"i":[{"n":"str"}],"o":{"n":"host"}}],[11,"from","","",13,{"i":[{"n":"t"}],"o":{"n":"host"}}],[11,"from","","",0,{"i":[{"g":["vec"],"n":"option"}],"o":{"n":"domainsvalidation"}}],[11,"from","","",1,{"i":[{"n":"t"}],"o":{"n":"accesscontrolalloworigin"}}],[11,"from","","",14,{"i":[{"n":"t"}],"o":{"n":"origin"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"into","","",3,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"into","","",0,{"i":[{"n":"self"}],"o":{"g":["vec"],"n":"option"}}],[11,"eq","","",1,{"i":[{"n":"self"},{"n":"accesscontrolalloworigin"}],"o":{"n":"bool"}}],[11,"ne","","",1,{"i":[{"n":"self"},{"n":"accesscontrolalloworigin"}],"o":{"n":"bool"}}],[11,"eq","","",13,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"ne","","",13,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"eq","","",14,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"ne","","",14,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"eq","","",3,{"i":[{"n":"self"},{"n":"corsheader"}],"o":{"n":"bool"}}],[11,"ne","","",3,{"i":[{"n":"self"},{"n":"corsheader"}],"o":{"n":"bool"}}],[11,"clone","","",14,{"i":[{"n":"self"}],"o":{"n":"origin"}}],[11,"clone","","",13,{"i":[{"n":"self"}],"o":{"n":"host"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"domainsvalidation"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"accesscontrolalloworigin"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"corsheader"}}],[11,"matches","","",14,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"matches","","",13,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"hash","","",14,null],[11,"hash","","",13,null],[11,"deref","","",13,null],[11,"deref","","",14,null],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",14,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"write","jsonrpc_http_server::tokio_core::net","",15,null],[11,"flush","","",15,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"write","jsonrpc_http_server::tokio_core::reactor","",16,null],[11,"flush","","",16,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"read","jsonrpc_http_server::tokio_core::net","",15,null],[11,"read","jsonrpc_http_server::tokio_core::reactor","",16,null],[11,"eq","","",17,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"ne","","",17,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"shutdown","jsonrpc_http_server::tokio_core::net","",15,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"write_buf","","",15,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"shutdown","jsonrpc_http_server::tokio_core::reactor","",16,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"as_raw_fd","jsonrpc_http_server::tokio_core::net","",18,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",19,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",15,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"prepare_uninitialized_buffer","","",15,null],[11,"read_buf","","",15,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"clone","jsonrpc_http_server::tokio_core::reactor","",17,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"clone","","",20,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"clone","","",21,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"execute","","",21,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",20,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",22,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::net","",23,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::reactor","",24,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::net","",25,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",26,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::reactor","",27,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_http_server::tokio_core::net","",28,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",29,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"start_send","","",23,null],[11,"poll_complete","","",23,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"close","","",23,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"hash","jsonrpc_http_server::tokio_core::reactor","",17,null],[11,"fmt","","",16,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",17,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_http_server::tokio_core::net","",15,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",18,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_http_server::tokio_core::reactor","",22,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_http_server::tokio_core::net","",19,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_http_server::tokio_core::reactor","",27,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",21,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",20,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"new","jsonrpc_http_server","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",14,{"i":[{"n":"originprotocol"},{"n":"str"},{"n":"t"}],"o":{"n":"origin"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",14,{"i":[{"n":"str"}],"o":{"n":"origin"}}],[11,"get_ref","jsonrpc_http_server::tokio_core::net","Returns a reference to the underlying I/O stream wrapped by `Framed`.",23,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",23,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",23,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",18,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",18,{"i":[{"n":"udpsocket"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",18,{"i":[{"n":"self"},{"n":"c"}],"o":{"n":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",18,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"connect","","Connects the UDP socket setting the default destination for send() and limiting packets that are read via recv from the address specified in addr.",18,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["error"],"n":"result"}}],[11,"send","","Sends data on the socket to the address previously bound via connect(). On success, returns the number of bytes written.",18,null],[11,"recv","","Receives data from the socket previously bound with connect(). On success, returns the number of bytes read.",18,null],[11,"poll_read","","Test whether this socket is ready to be read or not.",18,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",18,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",18,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",18,{"i":[{"n":"self"},{"n":"t"},{"n":"socketaddr"}],"o":{"n":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",18,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",18,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",18,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",18,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",19,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"bind2","","Create a new TCP listener associated with this event loop.",19,{"i":[{"n":"socketaddr"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",19,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"accept_std","","Like `accept`, except that it returns a raw `std::net::TcpStream`.",19,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",19,{"i":[{"n":"tcplistener"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",19,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",19,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",19,{"i":[{"n":"self"}],"o":{"n":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",19,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",19,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",19,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",19,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"connect","","Create a new TCP stream connected to the specified address.",15,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"n":"tcpstreamnew"}}],[11,"connect2","","Create a new TCP stream connected to the specified address.",15,{"i":[{"n":"socketaddr"}],"o":{"n":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",15,{"i":[{"n":"tcpstream"},{"n":"handle"}],"o":{"g":["tcpstream","error"],"n":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",15,{"i":[{"n":"tcpstream"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["future"],"n":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",15,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",15,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",15,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",15,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peek","","Receives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.",15,null],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",15,{"i":[{"n":"self"},{"n":"shutdown"}],"o":{"g":["error"],"n":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",15,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",15,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_recv_buffer_size","","Sets the value of the `SO_RCVBUF` option on this socket.",15,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"recv_buffer_size","","Gets the value of the `SO_RCVBUF` option on this socket.",15,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_send_buffer_size","","Sets the value of the `SO_SNDBUF` option on this socket.",15,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"send_buffer_size","","Gets the value of the `SO_SNDBUF` option on this socket.",15,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_keepalive","","Sets whether keepalive messages are enabled to be sent on this socket.",15,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"keepalive","","Returns whether keepalive messages are enabled on this socket, and if so the duration of time between them.",15,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",15,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",15,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",15,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",15,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_linger","","Sets the linger duration of this socket by setting the SO_LINGER option",15,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"linger","","reads the linger duration for this socket by getting the SO_LINGER option",15,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"new","jsonrpc_http_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",22,{"o":{"g":["core","error"],"n":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",22,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"runtime","","Returns a reference to the runtime backing the instance",22,{"i":[{"n":"self"}],"o":{"n":"runtime"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",22,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",22,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",22,null],[11,"id","","Get the ID of this loop",22,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",21,null],[11,"id","","Return the ID of the represented Core",21,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",21,{"i":[{"n":"self"}],"o":{"g":["handle"],"n":"option"}}],[11,"new_tokio_handle","","Returns a reference to the new Tokio handle",20,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",20,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",20,null],[11,"spawn_send","","Spawns a new future onto the threadpool",20,null],[11,"spawn_fn","","Spawns a closure on this event loop.",20,null],[11,"id","","Return the ID of the represented Core",20,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",24,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",24,{"i":[{"n":"instant"},{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",16,{"i":[{"n":"e"},{"n":"handle"}],"o":{"g":["pollevented","error"],"n":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",16,{"i":[{"n":"self"},{"n":"handle"}],"o":{"g":["error"],"n":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",16,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",16,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_ready","","Test to see whether this source fulfills any condition listed in `mask` provided.",16,{"i":[{"n":"self"},{"n":"ready"}],"o":{"g":["ready"],"n":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",16,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",16,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",16,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",16,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",16,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",27,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",27,{"i":[{"n":"instant"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"reset","","Resets this timeout to an new timeout which will fire at the time specified by `at`.",27,null],[11,"map","jsonrpc_http_server","Maps `Ok` variant of `CorsHeader`.",3,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"corsheader"}}]],"paths":[[4,"DomainsValidation"],[4,"AccessControlAllowOrigin"],[8,"UdpCodec"],[4,"CorsHeader"],[3,"Response"],[3,"Rpc"],[4,"RequestMiddlewareAction"],[4,"RestApi"],[3,"ServerHandler"],[8,"RequestMiddleware"],[8,"MetaExtractor"],[3,"ServerBuilder"],[3,"Server"],[3,"Host"],[3,"Origin"],[3,"TcpStream"],[3,"PollEvented"],[3,"CoreId"],[3,"UdpSocket"],[3,"TcpListener"],[3,"Handle"],[3,"Remote"],[3,"Core"],[3,"UdpFramed"],[3,"Interval"],[3,"Incoming"],[3,"SendDgram"],[3,"Timeout"],[3,"RecvDgram"],[3,"TcpStreamNew"]]};
searchIndex["jsonrpc_ipc_server"] = {"doc":"Cross-platform JSON-RPC IPC transport.","items":[[0,"net","jsonrpc_ipc_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[3,"UdpFramed","jsonrpc_ipc_server::tokio_core::net","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[8,"UdpCodec","","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",0,null],[16,"Out","","The type of frames to be encoded.",0,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",0,null],[10,"encode","","Encodes a frame into the buffer provided.",0,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[0,"reactor","jsonrpc_ipc_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_ipc_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[8,"SessionStats","jsonrpc_ipc_server","Keeps track of open sessions",null,null],[10,"open_session","","Executed when new session is opened.",1,null],[10,"close_session","","Executed when session is closed.",1,null],[6,"SessionId","","Session id",null,null],[3,"NoopExtractor","","Noop-extractor",null,null],[3,"RequestContext","","Request context",null,null],[12,"session_id","","Session ID",2,null],[12,"endpoint_addr","","Remote UDS endpoint",2,null],[12,"sender","","Direct pipe sender",2,null],[3,"Server","","IPC Server handle",null,null],[3,"ServerBuilder","","IPC server builder",null,null],[3,"CloseHandle","","`CloseHandle` allows one to stop an `IpcServer` remotely.",null,null],[11,"new","","Creates new IPC server build given the `IoHandler`.",3,{"i":[{"n":"t"}],"o":{"n":"serverbuilder"}}],[11,"with_meta_extractor","","Creates new IPC server build given the `IoHandler` and metadata extractor.",3,{"i":[{"n":"t"},{"n":"e"}],"o":{"n":"serverbuilder"}}],[11,"event_loop_remote","","Sets shared different event loop remote.",3,{"i":[{"n":"self"},{"n":"remote"}],"o":{"n":"self"}}],[11,"session_meta_extractor","","Sets session metadata extractor.",3,{"i":[{"n":"self"},{"n":"x"}],"o":{"n":"self"}}],[11,"session_stats","","Session stats",3,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"request_separators","","Sets the incoming and outgoing requests separator",3,{"i":[{"n":"self"},{"n":"separator"},{"n":"separator"}],"o":{"n":"self"}}],[11,"start","","Run server (in a separate thread)",3,{"i":[{"n":"self"},{"n":"str"}],"o":{"g":["server"],"n":"result"}}],[11,"close","","Closes the server (waits for finish)",4,{"i":[{"n":"self"}]}],[11,"close_handle","","Creates a close handle that can be used to stop the server remotely",4,{"i":[{"n":"self"}],"o":{"n":"closehandle"}}],[11,"wait","","Wait for the server to finish",4,{"i":[{"n":"self"}]}],[11,"clone","","",5,{"i":[{"n":"self"}],"o":{"n":"closehandle"}}],[11,"close","","`close` closes the corresponding `IpcServer` instance.",5,{"i":[{"n":"self"}]}],[11,"extract","","",6,{"i":[{"n":"self"},{"n":"requestcontext"}],"o":{"n":"m"}}],[8,"MetaExtractor","","Metadata extractor (per session)",null,null],[10,"extract","","Extracts metadata from request context",7,{"i":[{"n":"self"},{"n":"requestcontext"}],"o":{"n":"m"}}],[11,"write","jsonrpc_ipc_server::tokio_core::net","",8,null],[11,"flush","","",8,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"write","jsonrpc_ipc_server::tokio_core::reactor","",9,null],[11,"flush","","",9,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"read","jsonrpc_ipc_server::tokio_core::net","",8,null],[11,"read","jsonrpc_ipc_server::tokio_core::reactor","",9,null],[11,"eq","","",10,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"ne","","",10,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"shutdown","jsonrpc_ipc_server::tokio_core::net","",8,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"write_buf","","",8,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"shutdown","jsonrpc_ipc_server::tokio_core::reactor","",9,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"as_raw_fd","jsonrpc_ipc_server::tokio_core::net","",11,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",12,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",8,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"prepare_uninitialized_buffer","","",8,null],[11,"read_buf","","",8,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"clone","jsonrpc_ipc_server::tokio_core::reactor","",10,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"clone","","",13,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"clone","","",14,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"execute","","",14,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",13,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",15,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::net","",16,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::reactor","",17,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::net","",18,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",19,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::reactor","",20,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ipc_server::tokio_core::net","",21,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",22,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"start_send","","",16,null],[11,"poll_complete","","",16,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"close","","",16,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"hash","jsonrpc_ipc_server::tokio_core::reactor","",10,null],[11,"fmt","","",9,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",10,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ipc_server::tokio_core::net","",8,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",11,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ipc_server::tokio_core::reactor","",15,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ipc_server::tokio_core::net","",12,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ipc_server::tokio_core::reactor","",20,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",14,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"get_ref","jsonrpc_ipc_server::tokio_core::net","Returns a reference to the underlying I/O stream wrapped by `Framed`.",16,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",16,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",16,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",11,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",11,{"i":[{"n":"udpsocket"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",11,{"i":[{"n":"self"},{"n":"c"}],"o":{"n":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",11,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"connect","","Connects the UDP socket setting the default destination for send() and limiting packets that are read via recv from the address specified in addr.",11,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["error"],"n":"result"}}],[11,"send","","Sends data on the socket to the address previously bound via connect(). On success, returns the number of bytes written.",11,null],[11,"recv","","Receives data from the socket previously bound with connect(). On success, returns the number of bytes read.",11,null],[11,"poll_read","","Test whether this socket is ready to be read or not.",11,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",11,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",11,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",11,{"i":[{"n":"self"},{"n":"t"},{"n":"socketaddr"}],"o":{"n":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",11,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",11,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",11,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",11,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",11,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",11,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",11,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",11,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",11,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",11,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",11,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",11,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",12,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"bind2","","Create a new TCP listener associated with this event loop.",12,{"i":[{"n":"socketaddr"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",12,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"accept_std","","Like `accept`, except that it returns a raw `std::net::TcpStream`.",12,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",12,{"i":[{"n":"tcplistener"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",12,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",12,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",12,{"i":[{"n":"self"}],"o":{"n":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",12,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",12,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",12,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",12,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"connect","","Create a new TCP stream connected to the specified address.",8,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"n":"tcpstreamnew"}}],[11,"connect2","","Create a new TCP stream connected to the specified address.",8,{"i":[{"n":"socketaddr"}],"o":{"n":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",8,{"i":[{"n":"tcpstream"},{"n":"handle"}],"o":{"g":["tcpstream","error"],"n":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",8,{"i":[{"n":"tcpstream"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["future"],"n":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",8,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",8,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",8,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",8,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peek","","Receives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.",8,null],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",8,{"i":[{"n":"self"},{"n":"shutdown"}],"o":{"g":["error"],"n":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",8,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",8,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_recv_buffer_size","","Sets the value of the `SO_RCVBUF` option on this socket.",8,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"recv_buffer_size","","Gets the value of the `SO_RCVBUF` option on this socket.",8,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_send_buffer_size","","Sets the value of the `SO_SNDBUF` option on this socket.",8,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"send_buffer_size","","Gets the value of the `SO_SNDBUF` option on this socket.",8,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_keepalive","","Sets whether keepalive messages are enabled to be sent on this socket.",8,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"keepalive","","Returns whether keepalive messages are enabled on this socket, and if so the duration of time between them.",8,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",8,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",8,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",8,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",8,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_linger","","Sets the linger duration of this socket by setting the SO_LINGER option",8,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"linger","","reads the linger duration for this socket by getting the SO_LINGER option",8,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"new","jsonrpc_ipc_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",15,{"o":{"g":["core","error"],"n":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",15,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"runtime","","Returns a reference to the runtime backing the instance",15,{"i":[{"n":"self"}],"o":{"n":"runtime"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",15,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",15,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",15,null],[11,"id","","Get the ID of this loop",15,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",14,null],[11,"id","","Return the ID of the represented Core",14,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",14,{"i":[{"n":"self"}],"o":{"g":["handle"],"n":"option"}}],[11,"new_tokio_handle","","Returns a reference to the new Tokio handle",13,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",13,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",13,null],[11,"spawn_send","","Spawns a new future onto the threadpool",13,null],[11,"spawn_fn","","Spawns a closure on this event loop.",13,null],[11,"id","","Return the ID of the represented Core",13,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",17,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",17,{"i":[{"n":"instant"},{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",9,{"i":[{"n":"e"},{"n":"handle"}],"o":{"g":["pollevented","error"],"n":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",9,{"i":[{"n":"self"},{"n":"handle"}],"o":{"g":["error"],"n":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",9,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",9,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_ready","","Test to see whether this source fulfills any condition listed in `mask` provided.",9,{"i":[{"n":"self"},{"n":"ready"}],"o":{"g":["ready"],"n":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",9,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",9,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",9,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",9,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",9,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",20,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",20,{"i":[{"n":"instant"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"reset","","Resets this timeout to an new timeout which will fire at the time specified by `at`.",20,null]],"paths":[[8,"UdpCodec"],[8,"SessionStats"],[3,"RequestContext"],[3,"ServerBuilder"],[3,"Server"],[3,"CloseHandle"],[3,"NoopExtractor"],[8,"MetaExtractor"],[3,"TcpStream"],[3,"PollEvented"],[3,"CoreId"],[3,"UdpSocket"],[3,"TcpListener"],[3,"Handle"],[3,"Remote"],[3,"Core"],[3,"UdpFramed"],[3,"Interval"],[3,"Incoming"],[3,"SendDgram"],[3,"Timeout"],[3,"RecvDgram"],[3,"TcpStreamNew"]]};
searchIndex["jsonrpc_macros"] = {"doc":"High level, typed wrapper for `jsonrpc_core`.","items":[[3,"Trailing","jsonrpc_macros","A wrapper type without an implementation of `Deserialize` which allows a special implementation of `Wrap` for functions that take a trailing default parameter.",null,null],[3,"IoDelegate","","A set of RPC methods and notifications tied to single `delegate` struct.",null,null],[5,"to_value","","Converts a serializable value into `Value`.",null,{"i":[{"n":"t"}],"o":{"n":"value"}}],[11,"into","","",0,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"from","","",0,{"i":[{"n":"option"}],"o":{"n":"self"}}],[11,"unwrap_or","","Returns a underlying value if present or provided value.",0,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"t"}}],[11,"unwrap_or_else","","Returns an underlying value or computes it if not present.",0,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"t"}}],[11,"unwrap_or_default","","Returns an underlying value or the default value.",0,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"new","","Creates new `IoDelegate`",1,{"i":[{"n":"arc"}],"o":{"n":"self"}}],[11,"add_alias","","Adds an alias to existing method. NOTE: Aliases are not transitive, i.e. you cannot create alias to an alias.",1,{"i":[{"n":"self"},{"n":"str"},{"n":"str"}]}],[11,"add_method","","Adds async method to the delegate.",1,{"i":[{"n":"self"},{"n":"str"},{"n":"f"}]}],[11,"add_method_with_meta","","Adds async method with metadata to the delegate.",1,{"i":[{"n":"self"},{"n":"str"},{"n":"f"}]}],[11,"add_notification","","Adds notification to the delegate.",1,{"i":[{"n":"self"},{"n":"str"},{"n":"f"}]}],[11,"add_subscription","","Adds subscription to the delegate.",1,null],[11,"into","","",1,{"i":[{"n":"self"}],"o":{"g":["string","remoteprocedure"],"n":"hashmap"}}],[0,"pubsub","","PUB-SUB auto-serializing structures.",null,null],[4,"SubscriptionId","jsonrpc_macros::pubsub","Unique subscription id. NOTE Assigning same id to different requests will cause the previous request to be unsubscribed.",null,null],[13,"Number","","U64 number",2,null],[13,"String","","String",2,null],[3,"Subscriber","","New PUB-SUB subcriber.",null,null],[3,"Sink","","Subscriber sink.",null,null],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Wrap non-typed subscriber.",3,{"i":[{"n":"subscriber"}],"o":{"n":"self"}}],[11,"new_test","","Create new subscriber for tests.",3,null],[11,"reject","","Reject subscription with given error.",3,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"result"}}],[11,"assign_id","","Assign id to this subscriber. This method consumes `Subscriber` and returns `Sink` if the connection is still open or error otherwise.",3,{"i":[{"n":"self"},{"n":"subscriptionid"}],"o":{"g":["sink"],"n":"result"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",4,{"i":[{"n":"self"}],"o":{"n":"sink"}}],[11,"notify","","Sends a notification to the subscriber.",4,{"i":[{"n":"self"},{"n":"result"}],"o":{"n":"sinkresult"}}],[11,"start_send","","",4,null],[11,"poll_complete","","",4,{"i":[{"n":"self"}],"o":{"n":"poll"}}],[11,"close","","",4,{"i":[{"n":"self"}],"o":{"n":"poll"}}],[14,"metadata","jsonrpc_macros","Auto-generates an RPC trait from trait definition.",null,null],[14,"build_rpc_trait","","",null,null],[11,"parse_value","jsonrpc_macros::pubsub","Parses `core::Value` into unique subscription id.",2,{"i":[{"n":"value"}],"o":{"g":["subscriptionid"],"n":"option"}}],[11,"from","","",2,{"i":[{"n":"string"}],"o":{"n":"subscriptionid"}}],[11,"from","","",2,{"i":[{"n":"u64"}],"o":{"n":"subscriptionid"}}],[11,"eq","","",2,{"i":[{"n":"self"},{"n":"subscriptionid"}],"o":{"n":"bool"}}],[11,"ne","","",2,{"i":[{"n":"self"},{"n":"subscriptionid"}],"o":{"n":"bool"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"subscriptionid"}}],[11,"hash","","",2,null],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}]],"paths":[[3,"Trailing"],[3,"IoDelegate"],[4,"SubscriptionId"],[3,"Subscriber"],[3,"Sink"]]};
searchIndex["jsonrpc_minihttp_server"] = {"doc":"jsonrpc http server.","items":[[0,"cors","jsonrpc_minihttp_server","CORS handling utility functions",null,null],[4,"OriginProtocol","jsonrpc_minihttp_server::cors","Origin Protocol",null,null],[13,"Http","","Http protocol",0,null],[13,"Https","","Https protocol",0,null],[13,"Custom","","Custom protocol",0,null],[3,"Origin","","Request Origin",null,null],[4,"AccessControlAllowOrigin","","Origins allowed to access",null,null],[13,"Value","","Specific hostname",1,null],[13,"Null","","null-origin (file:///, sandboxed iframe)",1,null],[13,"Any","","Any non-null origin",1,null],[4,"CorsHeader","","CORS Header Result.",null,null],[13,"NotRequired","","CORS header was not required. Origin is not present in the request.",2,null],[13,"Invalid","","CORS header is not returned, Origin is not allowed to access the resource.",2,null],[13,"Ok","","CORS header to include in the response. Origin is allowed to access the resource.",2,null],[5,"get_cors_header","","Returns correct CORS header (if any) given list of allowed origins and current origin.",null,{"i":[{"g":["str"],"n":"option"},{"g":["str"],"n":"option"},{"n":"option"}],"o":{"g":["accesscontrolalloworigin"],"n":"corsheader"}}],[3,"Host","jsonrpc_minihttp_server","Host type",null,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",3,null],[13,"Disabled","","Disable domains validation completely.",3,null],[3,"Req","","Request",null,null],[3,"ServerBuilder","","Convenient JSON-RPC HTTP Server builder.",null,null],[3,"RpcService","","Tokio-proto JSON-RPC HTTP Service",null,null],[3,"RpcResponse","","RPC response wrapper",null,null],[3,"Server","","jsonrpc http server instance",null,null],[11,"new","","Creates new `Req` object",4,{"i":[{"n":"request"}],"o":{"n":"self"}}],[11,"method","","Returns request method",4,{"i":[{"n":"self"}],"o":{"n":"method"}}],[11,"header","","Returns value of first header with given name. `None` if header is not found or value is not utf-8 encoded",4,{"i":[{"n":"self"},{"n":"str"}],"o":{"g":["str"],"n":"option"}}],[11,"body","","Returns body of the request as a string",4,{"i":[{"n":"self"}],"o":{"n":"str"}}],[8,"MetaExtractor","","Extracts metadata from the HTTP request.",null,null],[10,"read_metadata","","Read the metadata from the request",5,{"i":[{"n":"self"},{"n":"req"}],"o":{"n":"m"}}],[11,"new","","Creates new `ServerBuilder` for given `IoHandler`.",6,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"with_meta_extractor","","Creates new `ServerBuilder` for given `IoHandler` and meta extractor.",6,{"i":[{"n":"t"},{"n":"e"}],"o":{"n":"self"}}],[11,"threads","","Sets number of threads of the server to run. (not available for windows) Panics when set to `0`.",6,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"self"}}],[11,"cors","","Configures a list of allowed CORS origins.",6,{"i":[{"n":"self"},{"g":["accesscontrolalloworigin"],"n":"domainsvalidation"}],"o":{"n":"self"}}],[11,"meta_extractor","","Configures metadata extractor",6,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"allow_only_bind_host","","Allow connections only with `Host` header set to binding address.",6,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"allowed_hosts","","Specify a list of valid `Host` headers. Binding address is allowed automatically.",6,{"i":[{"n":"self"},{"g":["host"],"n":"domainsvalidation"}],"o":{"n":"self"}}],[11,"start_http","","Start this JSON-RPC HTTP server trying to bind to specified `SocketAddr`.",6,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["server"],"n":"result"}}],[11,"call","","",7,null],[11,"poll","","",8,{"i":[{"n":"self"}],"o":{"n":"poll"}}],[11,"address","","Returns addresses of this server",9,{"i":[{"n":"self"}],"o":{"n":"socketaddr"}}],[11,"close","","Closes the server.",9,{"i":[{"n":"self"}]}],[11,"wait","","Will block, waiting for the server to finish.",9,{"i":[{"n":"self"}],"o":{"n":"result"}}],[11,"drop","","",9,{"i":[{"n":"self"}]}],[11,"from","","",10,{"i":[{"n":"t"}],"o":{"n":"host"}}],[11,"from","","",3,{"i":[{"g":["vec"],"n":"option"}],"o":{"n":"domainsvalidation"}}],[11,"from","jsonrpc_minihttp_server::cors","",1,{"i":[{"n":"t"}],"o":{"n":"accesscontrolalloworigin"}}],[11,"from","","",11,{"i":[{"n":"t"}],"o":{"n":"origin"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"into","","",2,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"into","jsonrpc_minihttp_server","",3,{"i":[{"n":"self"}],"o":{"g":["vec"],"n":"option"}}],[11,"eq","jsonrpc_minihttp_server::cors","",1,{"i":[{"n":"self"},{"n":"accesscontrolalloworigin"}],"o":{"n":"bool"}}],[11,"ne","","",1,{"i":[{"n":"self"},{"n":"accesscontrolalloworigin"}],"o":{"n":"bool"}}],[11,"eq","jsonrpc_minihttp_server","",10,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"ne","","",10,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"eq","jsonrpc_minihttp_server::cors","",11,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"ne","","",11,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"eq","jsonrpc_minihttp_server","",3,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"ne","","",3,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"eq","jsonrpc_minihttp_server::cors","",0,{"i":[{"n":"self"},{"n":"originprotocol"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"originprotocol"}],"o":{"n":"bool"}}],[11,"eq","","",2,{"i":[{"n":"self"},{"n":"corsheader"}],"o":{"n":"bool"}}],[11,"ne","","",2,{"i":[{"n":"self"},{"n":"corsheader"}],"o":{"n":"bool"}}],[11,"clone","","",11,{"i":[{"n":"self"}],"o":{"n":"origin"}}],[11,"clone","jsonrpc_minihttp_server","",10,{"i":[{"n":"self"}],"o":{"n":"host"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"domainsvalidation"}}],[11,"clone","jsonrpc_minihttp_server::cors","",0,{"i":[{"n":"self"}],"o":{"n":"originprotocol"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"accesscontrolalloworigin"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"corsheader"}}],[11,"matches","","",11,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"matches","jsonrpc_minihttp_server","",10,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"hash","jsonrpc_minihttp_server::cors","",0,null],[11,"hash","","",11,null],[11,"hash","jsonrpc_minihttp_server","",10,null],[11,"deref","","",10,null],[11,"deref","jsonrpc_minihttp_server::cors","",11,null],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_minihttp_server","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",10,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_minihttp_server::cors","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",11,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"new","","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",11,{"i":[{"n":"originprotocol"},{"n":"str"},{"n":"t"}],"o":{"n":"origin"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",11,{"i":[{"n":"str"}],"o":{"n":"origin"}}],[11,"map","","Maps `Ok` variant of `CorsHeader`.",2,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"corsheader"}}],[11,"new","jsonrpc_minihttp_server","Creates a new `Host` given hostname and port number.",10,{"i":[{"n":"str"},{"n":"t"}],"o":{"n":"host"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",10,{"i":[{"n":"str"}],"o":{"n":"host"}}]],"paths":[[4,"OriginProtocol"],[4,"AccessControlAllowOrigin"],[4,"CorsHeader"],[4,"DomainsValidation"],[3,"Req"],[8,"MetaExtractor"],[3,"ServerBuilder"],[3,"RpcService"],[3,"RpcResponse"],[3,"Server"],[3,"Host"],[3,"Origin"]]};
searchIndex["jsonrpc_pubsub"] = {"doc":"Publish-Subscribe extension for JSON-RPC","items":[[3,"PubSubHandler","jsonrpc_pubsub","Publish-Subscribe extension of `IoHandler`.",null,null],[3,"Session","","RPC client session Keeps track of active subscriptions and unsubscribes from them upon dropping.",null,null],[3,"Sink","","A handle to send notifications directly to subscribed client.",null,null],[3,"Subscriber","","Represents a subscribing client. Subscription handlers can either reject this subscription request or assign an unique id.",null,null],[4,"SubscriptionId","","Unique subscription id. NOTE Assigning same id to different requests will cause the previous request to be unsubscribed.",null,null],[13,"Number","","U64 number",0,null],[13,"String","","String",0,null],[5,"new_subscription","","Creates new subscribe and unsubscribe RPC methods",null,null],[11,"default","","",1,{"o":{"n":"self"}}],[11,"new","","Creates new `PubSubHandler`",1,{"i":[{"n":"metaiohandler"}],"o":{"n":"self"}}],[11,"add_subscription","","Adds new subscription.",1,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"into","","",1,{"i":[{"n":"self"}],"o":{"n":"metaiohandler"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates new session given transport raw send capabilities. Session should be created as part of metadata, `sender` should be returned by transport.",2,{"i":[{"g":["string"],"n":"sender"}],"o":{"n":"self"}}],[11,"sender","","Returns transport write stream",2,{"i":[{"n":"self"}],"o":{"g":["string"],"n":"sender"}}],[11,"on_drop","","Adds a function to call when session is dropped.",2,{"i":[{"n":"self"},{"g":["fn"],"n":"box"}]}],[11,"drop","","",2,{"i":[{"n":"self"}]}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"sink"}}],[11,"notify","","Sends a notification to a client.",3,{"i":[{"n":"self"},{"n":"params"}],"o":{"n":"sinkresult"}}],[11,"start_send","","",3,null],[11,"poll_complete","","",3,{"i":[{"n":"self"}],"o":{"n":"poll"}}],[11,"close","","",3,{"i":[{"n":"self"}],"o":{"n":"poll"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_test","","Creates new subscriber.",4,null],[11,"assign_id","","Consumes `Subscriber` and assigns unique id to a requestor. Returns `Err` if request has already terminated.",4,{"i":[{"n":"self"},{"n":"subscriptionid"}],"o":{"g":["sink"],"n":"result"}}],[11,"reject","","Rejects this subscription request with given error. Returns `Err` if request has already terminated.",4,{"i":[{"n":"self"},{"n":"error"}],"o":{"n":"result"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"subscriptionid"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"subscriptionid"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"subscriptionid"}],"o":{"n":"bool"}}],[11,"hash","","",0,null],[11,"parse_value","","Parses `core::Value` into unique subscription id.",0,{"i":[{"n":"value"}],"o":{"g":["subscriptionid"],"n":"option"}}],[11,"from","","",0,{"i":[{"n":"string"}],"o":{"n":"self"}}],[11,"from","","",0,{"i":[{"n":"u64"}],"o":{"n":"self"}}],[6,"TransportError","","Raw transport error.",null,null],[6,"SinkResult","","Subscription send result.",null,null],[8,"SubscribeRpcMethod","","Subscribe handler",null,null],[10,"call","","Called when client is requesting new subscription to be started.",5,{"i":[{"n":"self"},{"n":"params"},{"n":"m"},{"n":"subscriber"}]}],[8,"UnsubscribeRpcMethod","","Unsubscribe handler",null,null],[16,"Out","","Output type",6,null],[10,"call","","Called when client is requesting to cancel existing subscription.",6,null],[8,"PubSubMetadata","","Metadata extension for pub-sub method handling.",null,null],[10,"session","","Returns session object associated with given request/client. `None` indicates that sessions are not supported on the used transport.",7,{"i":[{"n":"self"}],"o":{"g":["arc"],"n":"option"}}]],"paths":[[4,"SubscriptionId"],[3,"PubSubHandler"],[3,"Session"],[3,"Sink"],[3,"Subscriber"],[8,"SubscribeRpcMethod"],[8,"UnsubscribeRpcMethod"],[8,"PubSubMetadata"]]};
searchIndex["jsonrpc_pubsub_examples"] = {"doc":"","items":[],"paths":[]};
searchIndex["jsonrpc_server_utils"] = {"doc":"JSON-RPC servers utilities.","items":[[0,"cors","jsonrpc_server_utils","CORS handling utility functions",null,null],[3,"Origin","jsonrpc_server_utils::cors","Request Origin",null,null],[4,"OriginProtocol","","Origin Protocol",null,null],[13,"Http","","Http protocol",0,null],[13,"Https","","Https protocol",0,null],[13,"Custom","","Custom protocol",0,null],[4,"AccessControlAllowOrigin","","Origins allowed to access",null,null],[13,"Value","","Specific hostname",1,null],[13,"Null","","null-origin (file:///, sandboxed iframe)",1,null],[13,"Any","","Any non-null origin",1,null],[4,"CorsHeader","","CORS Header Result.",null,null],[13,"NotRequired","","CORS header was not required. Origin is not present in the request.",2,null],[13,"Invalid","","CORS header is not returned, Origin is not allowed to access the resource.",2,null],[13,"Ok","","CORS header to include in the response. Origin is allowed to access the resource.",2,null],[5,"get_cors_header","","Returns correct CORS header (if any) given list of allowed origins and current origin.",null,{"i":[{"g":["str"],"n":"option"},{"g":["str"],"n":"option"},{"n":"option"}],"o":{"n":"corsheader"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"originprotocol"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"originprotocol"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"originprotocol"}],"o":{"n":"bool"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"origin"}}],[11,"eq","","",3,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"ne","","",3,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"hash","","",3,null],[11,"from","","",3,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"new","","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",3,{"i":[{"n":"originprotocol"},{"n":"str"},{"n":"t"}],"o":{"n":"self"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",3,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"matches","","",3,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"deref","","",3,null],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",1,{"i":[{"n":"self"}],"o":{"n":"accesscontrolalloworigin"}}],[11,"eq","","",1,{"i":[{"n":"self"},{"n":"accesscontrolalloworigin"}],"o":{"n":"bool"}}],[11,"ne","","",1,{"i":[{"n":"self"},{"n":"accesscontrolalloworigin"}],"o":{"n":"bool"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",1,{"i":[{"n":"t"}],"o":{"n":"accesscontrolalloworigin"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"corsheader"}}],[11,"eq","","",2,{"i":[{"n":"self"},{"n":"corsheader"}],"o":{"n":"bool"}}],[11,"ne","","",2,{"i":[{"n":"self"},{"n":"corsheader"}],"o":{"n":"bool"}}],[11,"map","","Maps `Ok` variant of `CorsHeader`.",2,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"corsheader"}}],[11,"into","","",2,{"i":[{"n":"self"}],"o":{"n":"option"}}],[0,"hosts","jsonrpc_server_utils","Host header validation.",null,null],[3,"Host","jsonrpc_server_utils::hosts","Host type",null,null],[4,"Port","","Port pattern",null,null],[13,"None","","No port specified (default port)",4,null],[13,"Pattern","","Port specified as a wildcard pattern",4,null],[13,"Fixed","","Fixed numeric port",4,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",5,null],[13,"Disabled","","Disable domains validation completely.",5,null],[5,"is_host_valid","","Returns `true` when `Host` header is whitelisted in `allowed_hosts`.",null,{"i":[{"g":["str"],"n":"option"},{"n":"option"}],"o":{"n":"bool"}}],[5,"update","","Updates given list of hosts with the address.",null,{"i":[{"g":["vec"],"n":"option"},{"n":"socketaddr"}],"o":{"g":["vec"],"n":"option"}}],[11,"clone","","",4,{"i":[{"n":"self"}],"o":{"n":"port"}}],[11,"hash","","",4,null],[11,"eq","","",4,{"i":[{"n":"self"},{"n":"port"}],"o":{"n":"bool"}}],[11,"ne","","",4,{"i":[{"n":"self"},{"n":"port"}],"o":{"n":"bool"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",4,{"i":[{"g":["u16"],"n":"option"}],"o":{"n":"self"}}],[11,"from","","",4,{"i":[{"n":"u16"}],"o":{"n":"port"}}],[11,"clone","","",6,{"i":[{"n":"self"}],"o":{"n":"host"}}],[11,"hash","","",6,null],[11,"eq","","",6,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"ne","","",6,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"fmt","","",6,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",6,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"new","","Creates a new `Host` given hostname and port number.",6,{"i":[{"n":"str"},{"n":"t"}],"o":{"n":"self"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",6,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"matches","","",6,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"deref","","",6,null],[11,"clone","","",5,{"i":[{"n":"self"}],"o":{"n":"domainsvalidation"}}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",5,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"ne","","",5,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"into","","",5,{"i":[{"n":"self"}],"o":{"g":["vec"],"n":"option"}}],[11,"from","","",5,{"i":[{"g":["vec"],"n":"option"}],"o":{"n":"self"}}],[0,"session","jsonrpc_server_utils","Session statistics.",null,null],[6,"SessionId","jsonrpc_server_utils::session","Session id",null,null],[8,"SessionStats","","Keeps track of open sessions",null,null],[10,"open_session","","Executed when new session is opened.",7,{"i":[{"n":"self"},{"n":"sessionid"}]}],[10,"close_session","","Executed when session is closed.",7,{"i":[{"n":"self"},{"n":"sessionid"}]}],[0,"reactor","jsonrpc_server_utils","Event Loop Remote Either spawns a new event loop, or re-uses provided one.",null,null],[3,"RpcEventLoop","jsonrpc_server_utils::reactor","A handle to running event loop. Dropping the handle will cause event loop to finish.",null,null],[4,"UninitializedRemote","","Possibly uninitialized event loop remote.",null,null],[13,"Shared","","Shared instance of remote.",8,null],[13,"Unspawned","","Event Loop should be spawned by the transport.",8,null],[4,"Remote","","Initialized Remote",null,null],[13,"Shared","","Shared instance",9,null],[13,"Spawned","","Spawned Event Loop",9,null],[11,"fmt","","",8,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"initialize","","Initializes remote. In case there is no shared remote, will spawn a new event loop. Dropping `Remote` closes the loop.",8,{"i":[{"n":"self"}],"o":{"g":["remote"],"n":"result"}}],[11,"init_with_name","","Initializes remote. In case there is no shared remote, will spawn a new event loop. Dropping `Remote` closes the loop.",8,{"i":[{"n":"self"},{"n":"t"}],"o":{"g":["remote"],"n":"result"}}],[11,"fmt","","",9,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"remote","","Get remote associated with this event loop.",9,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"close","","Closes underlying event loop (if any!).",9,{"i":[{"n":"self"}]}],[11,"wait","","Wait for underlying event loop to finish (if any!).",9,{"i":[{"n":"self"}]}],[11,"fmt","","",10,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"drop","","",10,{"i":[{"n":"self"}]}],[11,"spawn","","Spawns a new thread with the `EventLoop`.",10,{"o":{"n":"result"}}],[11,"with_name","","Spawns a new named thread with the `EventLoop`.",10,{"i":[{"g":["string"],"n":"option"}],"o":{"n":"result"}}],[11,"remote","","Get remote for this event loop.",10,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"wait","","Blocks current thread and waits until the event loop is finished.",10,{"i":[{"n":"self"}],"o":{"n":"result"}}],[11,"close","","Finishes this event loop.",10,{"i":[{"n":"self"}]}],[0,"codecs","jsonrpc_server_utils","Codecs utilities",null,null],[3,"StreamCodec","jsonrpc_server_utils::codecs","Stream codec for streaming protocols (ipc, tcp)",null,null],[4,"Separator","","Separator for enveloping messages in streaming codecs",null,null],[13,"Empty","","No envelope is expected between messages. Decoder will try to figure out message boundaries by accumulating incoming bytes until valid JSON is formed. Encoder will send messages without any boundaries between requests.",11,null],[13,"Byte","","Byte is used as an sentitel between messages",11,null],[8,"Pattern","jsonrpc_server_utils","Pattern that can be matched to string.",null,null],[10,"matches","","Returns true if given string matches the pattern.",12,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"fmt","jsonrpc_server_utils::codecs","",11,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",11,{"i":[{"n":"self"}],"o":{"n":"separator"}}],[11,"default","","",11,{"o":{"n":"self"}}],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",13,{"o":{"n":"streamcodec"}}],[11,"stream_incoming","","Default codec with streaming input data. Input can be both enveloped and not.",13,{"o":{"n":"self"}}],[11,"new","","New custom stream codec",13,{"i":[{"n":"separator"},{"n":"separator"}],"o":{"n":"self"}}],[11,"decode","","",13,{"i":[{"n":"self"},{"n":"bytesmut"}],"o":{"g":["option"],"n":"result"}}],[11,"encode","","",13,{"i":[{"n":"self"},{"n":"string"},{"n":"bytesmut"}],"o":{"n":"result"}}]],"paths":[[4,"OriginProtocol"],[4,"AccessControlAllowOrigin"],[4,"CorsHeader"],[3,"Origin"],[4,"Port"],[4,"DomainsValidation"],[3,"Host"],[8,"SessionStats"],[4,"UninitializedRemote"],[4,"Remote"],[3,"RpcEventLoop"],[4,"Separator"],[8,"Pattern"],[3,"StreamCodec"]]};
searchIndex["jsonrpc_tcp_server"] = {"doc":"jsonrpc server over tcp/ip","items":[[0,"net","jsonrpc_tcp_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[3,"UdpFramed","jsonrpc_tcp_server::tokio_core::net","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[8,"UdpCodec","","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",0,null],[16,"Out","","The type of frames to be encoded.",0,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",0,null],[10,"encode","","Encodes a frame into the buffer provided.",0,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[0,"reactor","jsonrpc_tcp_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_tcp_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[3,"Dispatcher","jsonrpc_tcp_server","Peer-messages dispatcher.",null,null],[3,"RequestContext","","Request context",null,null],[12,"peer_addr","","Peer Address",1,null],[12,"sender","","Peer Sender channel",1,null],[3,"ServerBuilder","","TCP server builder",null,null],[3,"Server","","TCP Server handle",null,null],[4,"PushMessageError","","Push Message Error",null,null],[13,"NoSuchPeer","","Invalid peer",2,null],[13,"Send","","Send error",2,null],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",2,{"i":[{"g":["string"],"n":"senderror"}],"o":{"n":"self"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"dispatcher"}}],[11,"new","","Creates a new dispatcher",3,{"i":[{"g":["mutex"],"n":"arc"}],"o":{"n":"self"}}],[11,"push_message","","Pushes message to given peer",3,{"i":[{"n":"self"},{"n":"socketaddr"},{"n":"string"}],"o":{"g":["pushmessageerror"],"n":"result"}}],[11,"is_connected","","Returns `true` if the peer is still connnected",3,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"n":"bool"}}],[11,"peer_count","","Returns current peer count.",3,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"new","","Creates new `SeverBuilder` wih given `IoHandler`",4,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"with_meta_extractor","","Creates new `SeverBuilder` wih given `IoHandler`",4,{"i":[{"n":"t"},{"n":"e"}],"o":{"n":"self"}}],[11,"event_loop_remote","","Utilize existing event loop remote.",4,{"i":[{"n":"self"},{"n":"remote"}],"o":{"n":"self"}}],[11,"session_meta_extractor","","Sets session meta extractor",4,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"request_separators","","Sets the incoming and outgoing requests separator",4,{"i":[{"n":"self"},{"n":"separator"},{"n":"separator"}],"o":{"n":"self"}}],[11,"start","","Starts a new server",4,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["server"],"n":"result"}}],[11,"dispatcher","","Returns dispatcher",4,{"i":[{"n":"self"}],"o":{"n":"dispatcher"}}],[11,"close","","Closes the server (waits for finish)",5,{"i":[{"n":"self"}]}],[11,"wait","","Wait for the server to finish",5,{"i":[{"n":"self"}]}],[11,"drop","","",5,{"i":[{"n":"self"}]}],[8,"MetaExtractor","","Metadata extractor (per session)",null,null],[10,"extract","","Extracts metadata from request context",6,{"i":[{"n":"self"},{"n":"requestcontext"}],"o":{"n":"m"}}],[11,"write","jsonrpc_tcp_server::tokio_core::net","",7,null],[11,"flush","","",7,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"write","jsonrpc_tcp_server::tokio_core::reactor","",8,null],[11,"flush","","",8,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"read","jsonrpc_tcp_server::tokio_core::net","",7,null],[11,"read","jsonrpc_tcp_server::tokio_core::reactor","",8,null],[11,"eq","","",9,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"ne","","",9,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"shutdown","jsonrpc_tcp_server::tokio_core::net","",7,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"write_buf","","",7,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"shutdown","jsonrpc_tcp_server::tokio_core::reactor","",8,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"as_raw_fd","jsonrpc_tcp_server::tokio_core::net","",10,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",11,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",7,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"prepare_uninitialized_buffer","","",7,null],[11,"read_buf","","",7,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"clone","jsonrpc_tcp_server::tokio_core::reactor","",9,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"clone","","",12,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"clone","","",13,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"execute","","",13,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",12,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",14,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::net","",15,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::reactor","",16,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::net","",17,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",18,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::reactor","",19,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_tcp_server::tokio_core::net","",20,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",21,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"start_send","","",15,null],[11,"poll_complete","","",15,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"close","","",15,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"hash","jsonrpc_tcp_server::tokio_core::reactor","",9,null],[11,"fmt","","",8,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",9,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_tcp_server::tokio_core::net","",7,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",10,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_tcp_server::tokio_core::reactor","",14,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_tcp_server::tokio_core::net","",11,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_tcp_server::tokio_core::reactor","",19,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",12,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"get_ref","jsonrpc_tcp_server::tokio_core::net","Returns a reference to the underlying I/O stream wrapped by `Framed`.",15,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",15,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",15,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",10,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",10,{"i":[{"n":"udpsocket"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",10,{"i":[{"n":"self"},{"n":"c"}],"o":{"n":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",10,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"connect","","Connects the UDP socket setting the default destination for send() and limiting packets that are read via recv from the address specified in addr.",10,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["error"],"n":"result"}}],[11,"send","","Sends data on the socket to the address previously bound via connect(). On success, returns the number of bytes written.",10,null],[11,"recv","","Receives data from the socket previously bound with connect(). On success, returns the number of bytes read.",10,null],[11,"poll_read","","Test whether this socket is ready to be read or not.",10,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",10,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",10,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",10,{"i":[{"n":"self"},{"n":"t"},{"n":"socketaddr"}],"o":{"n":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",10,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",10,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",10,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",10,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",10,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",10,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",10,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",10,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",10,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",10,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",10,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",10,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",10,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",10,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",10,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",10,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",10,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",10,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",11,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"bind2","","Create a new TCP listener associated with this event loop.",11,{"i":[{"n":"socketaddr"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",11,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"accept_std","","Like `accept`, except that it returns a raw `std::net::TcpStream`.",11,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",11,{"i":[{"n":"tcplistener"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",11,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",11,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",11,{"i":[{"n":"self"}],"o":{"n":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",11,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",11,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",11,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"connect","","Create a new TCP stream connected to the specified address.",7,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"n":"tcpstreamnew"}}],[11,"connect2","","Create a new TCP stream connected to the specified address.",7,{"i":[{"n":"socketaddr"}],"o":{"n":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",7,{"i":[{"n":"tcpstream"},{"n":"handle"}],"o":{"g":["tcpstream","error"],"n":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",7,{"i":[{"n":"tcpstream"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["future"],"n":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",7,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",7,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",7,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",7,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peek","","Receives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.",7,null],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",7,{"i":[{"n":"self"},{"n":"shutdown"}],"o":{"g":["error"],"n":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",7,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",7,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_recv_buffer_size","","Sets the value of the `SO_RCVBUF` option on this socket.",7,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"recv_buffer_size","","Gets the value of the `SO_RCVBUF` option on this socket.",7,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_send_buffer_size","","Sets the value of the `SO_SNDBUF` option on this socket.",7,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"send_buffer_size","","Gets the value of the `SO_SNDBUF` option on this socket.",7,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_keepalive","","Sets whether keepalive messages are enabled to be sent on this socket.",7,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"keepalive","","Returns whether keepalive messages are enabled on this socket, and if so the duration of time between them.",7,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",7,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",7,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",7,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",7,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_linger","","Sets the linger duration of this socket by setting the SO_LINGER option",7,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"linger","","reads the linger duration for this socket by getting the SO_LINGER option",7,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"new","jsonrpc_tcp_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",14,{"o":{"g":["core","error"],"n":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",14,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"runtime","","Returns a reference to the runtime backing the instance",14,{"i":[{"n":"self"}],"o":{"n":"runtime"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",14,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",14,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",14,null],[11,"id","","Get the ID of this loop",14,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",13,null],[11,"id","","Return the ID of the represented Core",13,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",13,{"i":[{"n":"self"}],"o":{"g":["handle"],"n":"option"}}],[11,"new_tokio_handle","","Returns a reference to the new Tokio handle",12,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",12,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",12,null],[11,"spawn_send","","Spawns a new future onto the threadpool",12,null],[11,"spawn_fn","","Spawns a closure on this event loop.",12,null],[11,"id","","Return the ID of the represented Core",12,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",16,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",16,{"i":[{"n":"instant"},{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",8,{"i":[{"n":"e"},{"n":"handle"}],"o":{"g":["pollevented","error"],"n":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",8,{"i":[{"n":"self"},{"n":"handle"}],"o":{"g":["error"],"n":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",8,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",8,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_ready","","Test to see whether this source fulfills any condition listed in `mask` provided.",8,{"i":[{"n":"self"},{"n":"ready"}],"o":{"g":["ready"],"n":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",8,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",8,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",8,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",8,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",8,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",19,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",19,{"i":[{"n":"instant"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"reset","","Resets this timeout to an new timeout which will fire at the time specified by `at`.",19,null]],"paths":[[8,"UdpCodec"],[3,"RequestContext"],[4,"PushMessageError"],[3,"Dispatcher"],[3,"ServerBuilder"],[3,"Server"],[8,"MetaExtractor"],[3,"TcpStream"],[3,"PollEvented"],[3,"CoreId"],[3,"UdpSocket"],[3,"TcpListener"],[3,"Handle"],[3,"Remote"],[3,"Core"],[3,"UdpFramed"],[3,"Interval"],[3,"Incoming"],[3,"SendDgram"],[3,"Timeout"],[3,"RecvDgram"],[3,"TcpStreamNew"]]};
searchIndex["jsonrpc_test"] = {"doc":"An utility package to test jsonrpc-core based projects.","items":[[3,"Options","jsonrpc_test","Test RPC options.",null,null],[12,"no_print","","Disable printing requests and responses.",0,null],[3,"Rpc","","RPC instance.",null,null],[12,"io","","Underlying `IoHandler`.",1,null],[12,"options","","Options",1,null],[11,"default","","",0,{"o":{"n":"options"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",1,{"o":{"n":"rpc"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",1,{"i":[{"n":"iohandler"}],"o":{"n":"self"}}],[11,"new","","Create a new RPC instance from a single delegate.",1,{"i":[{"n":"d"}],"o":{"n":"self"}}],[11,"request","","Perform a single, synchronous method call.",1,{"i":[{"n":"self"},{"n":"str"},{"n":"t"}],"o":{"n":"string"}}]],"paths":[[3,"Options"],[3,"Rpc"]]};
searchIndex["jsonrpc_ws_server"] = {"doc":"`WebSockets` server.","items":[[3,"Origin","jsonrpc_ws_server","Request Origin",null,null],[3,"Host","","Host type",null,null],[4,"DomainsValidation","","Specifies if domains should be validated.",null,null],[13,"AllowOnly","","Allow only domains on the list.",0,null],[13,"Disabled","","Disable domains validation completely.",0,null],[0,"net","jsonrpc_ws_server::tokio_core","TCP/UDP bindings for `tokio-core`",null,null],[3,"UdpFramed","jsonrpc_ws_server::tokio_core::net","A unified `Stream` and `Sink` interface to an underlying `UdpSocket`, using the `UdpCodec` trait to encode and decode frames.",null,null],[3,"UdpSocket","","An I/O object representing a UDP socket.",null,null],[3,"TcpStreamNew","","Future returned by `TcpStream::connect` which will resolve to a `TcpStream` when the stream is connected.",null,null],[3,"RecvDgram","","A future used to receive a datagram from a UDP socket.",null,null],[3,"SendDgram","","A future used to write the entire contents of some data to a UDP socket.",null,null],[3,"Incoming","","Stream returned by the `TcpListener::incoming` function representing the stream of sockets received from a listener.",null,null],[8,"UdpCodec","","Encoding of frames via buffers.",null,null],[16,"In","","The type of decoded frames.",1,null],[16,"Out","","The type of frames to be encoded.",1,null],[10,"decode","","Attempts to decode a frame from the provided buffer of bytes.",1,null],[10,"encode","","Encodes a frame into the buffer provided.",1,null],[3,"TcpListener","","An I/O object representing a TCP socket listening for incoming connections.",null,null],[3,"TcpStream","","An I/O object representing a TCP stream connected to a remote endpoint.",null,null],[0,"reactor","jsonrpc_ws_server::tokio_core","The core reactor driving all I/O",null,null],[3,"Core","jsonrpc_ws_server::tokio_core::reactor","An event loop.",null,null],[3,"CoreId","","An unique ID for a Core",null,null],[3,"Remote","","Handle to an event loop, used to construct I/O objects, send messages, and otherwise interact indirectly with the event loop itself.",null,null],[3,"Handle","","A non-sendable handle to an event loop, useful for manufacturing instances of `LoopData`.",null,null],[3,"Interval","","A stream representing notifications at fixed interval",null,null],[3,"PollEvented","","A concrete implementation of a stream of readiness notifications for I/O objects that originates from an event loop.",null,null],[3,"Timeout","","A future representing the notification that a timeout has occurred.",null,null],[6,"SessionId","jsonrpc_ws_server","Session id",null,null],[8,"SessionStats","","Keeps track of open sessions",null,null],[10,"open_session","","Executed when new session is opened.",2,null],[10,"close_session","","Executed when session is closed.",2,null],[3,"Error","","The Error type.",null,null],[12,"0","","The kind of the error.",3,null],[3,"RequestContext","","Request context",null,null],[12,"session_id","","Session id",4,null],[12,"origin","","Request Origin",4,null],[12,"protocols","","Requested protocols",4,null],[12,"out","","Direct channel to send messages to a client.",4,null],[12,"remote","","Remote to underlying event loop.",4,null],[3,"NoopExtractor","","Dummy metadata extractor",null,null],[3,"CloseHandle","","A handle that allows closing of a server even if it owned by a thread blocked in `wait`.",null,null],[3,"Server","","`WebSockets` server implementation.",null,null],[3,"ServerBuilder","","Builder for `WebSockets` server",null,null],[4,"ErrorKind","","The kind of an error.",null,null],[13,"Msg","","A convenient variant for String.",5,null],[13,"Io","","",5,null],[13,"ConnectionClosed","","Attempted action on closed connection.",5,null],[4,"MiddlewareAction","","Request middleware action",null,null],[13,"Proceed","","Proceed with standard JSON-RPC behaviour.",6,null],[13,"Respond","","Terminate the request and return a response.",6,null],[12,"response","jsonrpc_ws_server::MiddlewareAction","Response to return",6,null],[12,"validate_origin","","Should origin be validated before returning the response?",6,null],[12,"validate_hosts","","Should hosts be validated before returning the response?",6,null],[11,"fmt","jsonrpc_ws_server","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","",3,{"i":[{"n":"errorkind"},{"n":"state"}],"o":{"n":"error"}}],[11,"from_kind","","",3,null],[11,"with_chain","","",3,{"i":[{"n":"e"},{"n":"k"}],"o":{"n":"self"}}],[11,"kind","","",3,null],[11,"iter","","",3,{"i":[{"n":"self"}],"o":{"n":"iter"}}],[11,"chain_err","","",3,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"self"}}],[11,"backtrace","","",3,{"i":[{"n":"self"}],"o":{"g":["backtrace"],"n":"option"}}],[11,"extract_backtrace","","",3,{"i":[{"n":"error"}],"o":{"g":["internalbacktrace"],"n":"option"}}],[11,"from_kind","","Constructs an error from a kind, and generates a backtrace.",3,{"i":[{"n":"errorkind"}],"o":{"n":"error"}}],[11,"with_chain","","Constructs a chained error from another error and a kind, and generates a backtrace.",3,{"i":[{"n":"e"},{"n":"k"}],"o":{"n":"error"}}],[11,"with_boxed_chain","","Construct a chained error from another boxed error and a kind, and generates a backtrace",3,{"i":[{"g":["error"],"n":"box"},{"n":"k"}],"o":{"n":"error"}}],[11,"kind","","Returns the kind of the error.",3,{"i":[{"n":"self"}],"o":{"n":"errorkind"}}],[11,"iter","","Iterates over the error chain.",3,{"i":[{"n":"self"}],"o":{"n":"iter"}}],[11,"backtrace","","Returns the backtrace associated with this error.",3,{"i":[{"n":"self"}],"o":{"g":["backtrace"],"n":"option"}}],[11,"chain_err","","Extends the error chain with a new entry.",3,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"error"}}],[11,"description","","A short description of the error. This method is identical to `Error::description()`",3,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"description","","",3,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"cause","","",3,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"option"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",3,{"i":[{"n":"error"}],"o":{"n":"self"}}],[11,"from","","",3,{"i":[{"n":"errorkind"}],"o":{"n":"self"}}],[11,"from","","",3,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"from","","",3,{"i":[{"n":"string"}],"o":{"n":"self"}}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"description","","A string describing the error kind.",5,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"from","","",5,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"from","","",5,{"i":[{"n":"string"}],"o":{"n":"self"}}],[11,"from","","",5,{"i":[{"n":"error"}],"o":{"n":"self"}}],[11,"from","","",3,{"i":[{"n":"error"}],"o":{"n":"self"}}],[11,"sender","","Get this session as a `Sink` spawning a new future in the underlying event loop.",4,{"i":[{"n":"self"}],"o":{"g":["string"],"n":"sender"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",7,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",7,{"i":[{"n":"self"}],"o":{"n":"noopextractor"}}],[11,"extract","","",7,{"i":[{"n":"self"},{"n":"requestcontext"}],"o":{"n":"m"}}],[11,"fmt","","",8,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"addr","","Returns the address this server is listening on",8,{"i":[{"n":"self"}],"o":{"n":"socketaddr"}}],[11,"start","","Starts a new `WebSocket` server in separate thread. Returns a `Server` handle which closes the server when droped.",8,{"i":[{"n":"socketaddr"},{"g":["metaiohandler"],"n":"arc"},{"g":["metaextractor"],"n":"arc"},{"g":["vec"],"n":"option"},{"g":["vec"],"n":"option"},{"g":["arc"],"n":"option"},{"g":["arc"],"n":"option"},{"n":"uninitializedremote"},{"n":"usize"}],"o":{"g":["server"],"n":"result"}}],[11,"wait","","Consumes the server and waits for completion",8,{"i":[{"n":"self"}],"o":{"n":"result"}}],[11,"close","","Closes the server and waits for it to finish",8,{"i":[{"n":"self"}]}],[11,"close_handle","","Returns a handle to the server that can be used to close it while another thread is blocking in `wait`.",8,{"i":[{"n":"self"}],"o":{"n":"closehandle"}}],[11,"drop","","",8,{"i":[{"n":"self"}]}],[11,"clone","","",9,{"i":[{"n":"self"}],"o":{"n":"closehandle"}}],[11,"close","","Closes the `Server`.",9,{"i":[{"n":"self"}]}],[11,"new","","Creates new `ServerBuilder`",10,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"with_meta_extractor","","Creates new `ServerBuilder`",10,{"i":[{"n":"t"},{"n":"e"}],"o":{"n":"self"}}],[11,"event_loop_remote","","Utilize existing event loop remote to poll RPC results.",10,{"i":[{"n":"self"},{"n":"remote"}],"o":{"n":"self"}}],[11,"session_meta_extractor","","Sets a meta extractor.",10,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"allowed_origins","","Allowed origins.",10,{"i":[{"n":"self"},{"g":["origin"],"n":"domainsvalidation"}],"o":{"n":"self"}}],[11,"allowed_hosts","","Allowed hosts.",10,{"i":[{"n":"self"},{"g":["host"],"n":"domainsvalidation"}],"o":{"n":"self"}}],[11,"session_stats","","Session stats",10,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"request_middleware","","Sets a request middleware. Middleware will be invoked before each handshake request. You can either terminate the handshake in the middleware or run a default behaviour after.",10,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"max_connections","","Maximal number of concurrent connections this server supports. Default: 100",10,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"self"}}],[11,"start","","Starts a new `WebSocket` server in separate thread. Returns a `Server` handle which closes the server when droped.",10,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["server"],"n":"result"}}],[11,"fmt","","",6,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",6,{"i":[{"g":["response"],"n":"option"}],"o":{"n":"self"}}],[6,"Result","","Convenient wrapper around `std::Result`.",null,null],[8,"MetaExtractor","","Metadata extractor from session data.",null,null],[10,"extract","","Extract metadata for given session",11,{"i":[{"n":"self"},{"n":"requestcontext"}],"o":{"n":"m"}}],[8,"RequestMiddleware","","Middleware to intercept server requests. You can either terminate the request (by returning a response) or just proceed with standard JSON-RPC handling.",null,null],[10,"process","","Process a request and decide what to do next.",12,{"i":[{"n":"self"},{"n":"request"}],"o":{"n":"middlewareaction"}}],[11,"new","","Creates new origin given protocol, hostname and port parts. Pre-processes input data if necessary.",13,{"i":[{"n":"originprotocol"},{"n":"str"},{"n":"t"}],"o":{"n":"origin"}}],[11,"parse","","Attempts to parse given string as a `Origin`. NOTE: This method always succeeds and falls back to sensible defaults.",13,{"i":[{"n":"str"}],"o":{"n":"origin"}}],[11,"from","","",14,{"i":[{"n":"t"}],"o":{"n":"host"}}],[11,"from","","",0,{"i":[{"g":["vec"],"n":"option"}],"o":{"n":"domainsvalidation"}}],[11,"from","","",13,{"i":[{"n":"t"}],"o":{"n":"origin"}}],[11,"into","","",0,{"i":[{"n":"self"}],"o":{"g":["vec"],"n":"option"}}],[11,"eq","","",14,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"ne","","",14,{"i":[{"n":"self"},{"n":"host"}],"o":{"n":"bool"}}],[11,"eq","","",13,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"ne","","",13,{"i":[{"n":"self"},{"n":"origin"}],"o":{"n":"bool"}}],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"domainsvalidation"}],"o":{"n":"bool"}}],[11,"clone","","",13,{"i":[{"n":"self"}],"o":{"n":"origin"}}],[11,"clone","","",14,{"i":[{"n":"self"}],"o":{"n":"host"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"domainsvalidation"}}],[11,"matches","","",13,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"matches","","",14,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[11,"hash","","",13,null],[11,"hash","","",14,null],[11,"deref","","",14,null],[11,"deref","","",13,null],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",14,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"write","jsonrpc_ws_server::tokio_core::net","",15,null],[11,"flush","","",15,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"write","jsonrpc_ws_server::tokio_core::reactor","",16,null],[11,"flush","","",16,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"read","jsonrpc_ws_server::tokio_core::net","",15,null],[11,"read","jsonrpc_ws_server::tokio_core::reactor","",16,null],[11,"eq","","",17,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"ne","","",17,{"i":[{"n":"self"},{"n":"coreid"}],"o":{"n":"bool"}}],[11,"shutdown","jsonrpc_ws_server::tokio_core::net","",15,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"write_buf","","",15,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"shutdown","jsonrpc_ws_server::tokio_core::reactor","",16,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"as_raw_fd","jsonrpc_ws_server::tokio_core::net","",18,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",19,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"as_raw_fd","","",15,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"prepare_uninitialized_buffer","","",15,null],[11,"read_buf","","",15,{"i":[{"n":"self"},{"n":"b"}],"o":{"g":["async","error"],"n":"result"}}],[11,"clone","jsonrpc_ws_server::tokio_core::reactor","",17,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"clone","","",20,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"clone","","",21,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"execute","","",21,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",20,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"execute","","",22,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["executeerror"],"n":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::net","",23,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::reactor","",24,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::net","",25,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",26,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::reactor","",27,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","jsonrpc_ws_server::tokio_core::net","",28,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"poll","","",29,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"start_send","","",23,null],[11,"poll_complete","","",23,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"close","","",23,{"i":[{"n":"self"}],"o":{"g":["async","error"],"n":"result"}}],[11,"hash","jsonrpc_ws_server::tokio_core::reactor","",17,null],[11,"fmt","","",16,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",17,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ws_server::tokio_core::net","",15,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",18,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ws_server::tokio_core::reactor","",22,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ws_server::tokio_core::net","",19,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","jsonrpc_ws_server::tokio_core::reactor","",27,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",21,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"fmt","","",20,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}],[11,"new","jsonrpc_ws_server","Creates a new `Host` given hostname and port number.",14,{"i":[{"n":"str"},{"n":"t"}],"o":{"n":"host"}}],[11,"parse","","Attempts to parse given string as a `Host`. NOTE: This method always succeeds and falls back to sensible defaults.",14,{"i":[{"n":"str"}],"o":{"n":"host"}}],[11,"get_ref","jsonrpc_ws_server::tokio_core::net","Returns a reference to the underlying I/O stream wrapped by `Framed`.",23,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O stream wrapped by `Framed`.",23,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"into_inner","","Consumes the `Framed`, returning its underlying I/O stream.",23,{"i":[{"n":"self"}],"o":{"n":"udpsocket"}}],[11,"bind","","Create a new UDP socket bound to the specified address.",18,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"from_socket","","Creates a new `UdpSocket` from the previously bound socket provided.",18,{"i":[{"n":"udpsocket"},{"n":"handle"}],"o":{"g":["udpsocket","error"],"n":"result"}}],[11,"framed","","Provides a `Stream` and `Sink` interface for reading and writing to this `UdpSocket` object, using the provided `UdpCodec` to read and write the raw data.",18,{"i":[{"n":"self"},{"n":"c"}],"o":{"n":"udpframed"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",18,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"connect","","Connects the UDP socket setting the default destination for send() and limiting packets that are read via recv from the address specified in addr.",18,{"i":[{"n":"self"},{"n":"socketaddr"}],"o":{"g":["error"],"n":"result"}}],[11,"send","","Sends data on the socket to the address previously bound via connect(). On success, returns the number of bytes written.",18,null],[11,"recv","","Receives data from the socket previously bound with connect(). On success, returns the number of bytes read.",18,null],[11,"poll_read","","Test whether this socket is ready to be read or not.",18,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",18,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"send_to","","Sends data on the socket to the given address. On success, returns the number of bytes written.",18,null],[11,"send_dgram","","Creates a future that will write the entire contents of the buffer `buf` provided as a datagram to this socket.",18,{"i":[{"n":"self"},{"n":"t"},{"n":"socketaddr"}],"o":{"n":"senddgram"}}],[11,"recv_from","","Receives data from the socket. On success, returns the number of bytes read and the address from whence the data came.",18,null],[11,"recv_dgram","","Creates a future that receive a datagram to be written to the buffer provided.",18,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"recvdgram"}}],[11,"broadcast","","Gets the value of the `SO_BROADCAST` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_broadcast","","Sets the value of the `SO_BROADCAST` option for this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v4","","Gets the value of the `IP_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v4","","Sets the value of the `IP_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_ttl_v4","","Gets the value of the `IP_MULTICAST_TTL` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_multicast_ttl_v4","","Sets the value of the `IP_MULTICAST_TTL` option for this socket.",18,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"multicast_loop_v6","","Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_multicast_loop_v6","","Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",18,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v4","","Executes an operation of the `IP_ADD_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"join_multicast_v6","","Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v4","","Executes an operation of the `IP_DROP_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv4addr"},{"n":"ipv4addr"}],"o":{"g":["error"],"n":"result"}}],[11,"leave_multicast_v6","","Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.",18,{"i":[{"n":"self"},{"n":"ipv6addr"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",18,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",18,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"bind","","Create a new TCP listener associated with this event loop.",19,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"bind2","","Create a new TCP listener associated with this event loop.",19,{"i":[{"n":"socketaddr"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"accept","","Attempt to accept a connection and create a new connected `TcpStream` if successful.",19,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"accept_std","","Like `accept`, except that it returns a raw `std::net::TcpStream`.",19,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"result"}}],[11,"from_listener","","Create a new TCP listener from the standard library's TCP listener.",19,{"i":[{"n":"tcplistener"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["tcplistener","error"],"n":"result"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",19,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this listener is bound to.",19,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"incoming","","Consumes this listener, returning a stream of the sockets this listener accepts.",19,{"i":[{"n":"self"}],"o":{"n":"incoming"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",19,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",19,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",19,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",19,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"connect","","Create a new TCP stream connected to the specified address.",15,{"i":[{"n":"socketaddr"},{"n":"handle"}],"o":{"n":"tcpstreamnew"}}],[11,"connect2","","Create a new TCP stream connected to the specified address.",15,{"i":[{"n":"socketaddr"}],"o":{"n":"tcpstreamnew"}}],[11,"from_stream","","Create a new `TcpStream` from a `net::TcpStream`.",15,{"i":[{"n":"tcpstream"},{"n":"handle"}],"o":{"g":["tcpstream","error"],"n":"result"}}],[11,"connect_stream","","Creates a new `TcpStream` from the pending socket inside the given `std::net::TcpStream`, connecting it to the address specified.",15,{"i":[{"n":"tcpstream"},{"n":"socketaddr"},{"n":"handle"}],"o":{"g":["future"],"n":"box"}}],[11,"poll_read","","Test whether this socket is ready to be read or not.",15,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Test whether this socket is ready to be written to or not.",15,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"local_addr","","Returns the local address that this stream is bound to.",15,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peer_addr","","Returns the remote address that this stream is connected to.",15,{"i":[{"n":"self"}],"o":{"g":["socketaddr","error"],"n":"result"}}],[11,"peek","","Receives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.",15,null],[11,"shutdown","","Shuts down the read, write, or both halves of this connection.",15,{"i":[{"n":"self"},{"n":"shutdown"}],"o":{"g":["error"],"n":"result"}}],[11,"set_nodelay","","Sets the value of the `TCP_NODELAY` option on this socket.",15,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"nodelay","","Gets the value of the `TCP_NODELAY` option on this socket.",15,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_recv_buffer_size","","Sets the value of the `SO_RCVBUF` option on this socket.",15,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"recv_buffer_size","","Gets the value of the `SO_RCVBUF` option on this socket.",15,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_send_buffer_size","","Sets the value of the `SO_SNDBUF` option on this socket.",15,{"i":[{"n":"self"},{"n":"usize"}],"o":{"g":["error"],"n":"result"}}],[11,"send_buffer_size","","Gets the value of the `SO_SNDBUF` option on this socket.",15,{"i":[{"n":"self"}],"o":{"g":["usize","error"],"n":"result"}}],[11,"set_keepalive","","Sets whether keepalive messages are enabled to be sent on this socket.",15,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"keepalive","","Returns whether keepalive messages are enabled on this socket, and if so the duration of time between them.",15,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"set_ttl","","Sets the value for the `IP_TTL` option on this socket.",15,{"i":[{"n":"self"},{"n":"u32"}],"o":{"g":["error"],"n":"result"}}],[11,"ttl","","Gets the value of the `IP_TTL` option for this socket.",15,{"i":[{"n":"self"}],"o":{"g":["u32","error"],"n":"result"}}],[11,"set_only_v6","","Sets the value for the `IPV6_V6ONLY` option on this socket.",15,{"i":[{"n":"self"},{"n":"bool"}],"o":{"g":["error"],"n":"result"}}],[11,"only_v6","","Gets the value of the `IPV6_V6ONLY` option for this socket.",15,{"i":[{"n":"self"}],"o":{"g":["bool","error"],"n":"result"}}],[11,"set_linger","","Sets the linger duration of this socket by setting the SO_LINGER option",15,{"i":[{"n":"self"},{"g":["duration"],"n":"option"}],"o":{"g":["error"],"n":"result"}}],[11,"linger","","reads the linger duration for this socket by getting the SO_LINGER option",15,{"i":[{"n":"self"}],"o":{"g":["option","error"],"n":"result"}}],[11,"new","jsonrpc_ws_server::tokio_core::reactor","Creates a new event loop, returning any error that happened during the creation.",22,{"o":{"g":["core","error"],"n":"result"}}],[11,"handle","","Returns a handle to this event loop which cannot be sent across threads but can be used as a proxy to the event loop itself.",22,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"runtime","","Returns a reference to the runtime backing the instance",22,{"i":[{"n":"self"}],"o":{"n":"runtime"}}],[11,"remote","","Generates a remote handle to this event loop which can be used to spawn tasks from other threads into this event loop.",22,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"run","","Runs a future until completion, driving the event loop while we're otherwise waiting for the future to complete.",22,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"result"}}],[11,"turn","","Performs one iteration of the event loop, blocking on waiting for events for at most `max_wait` (forever if `None`).",22,null],[11,"id","","Get the ID of this loop",22,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"spawn","","Spawns a new future into the event loop this remote is associated with.",21,null],[11,"id","","Return the ID of the represented Core",21,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"handle","","Attempts to \"promote\" this remote to a handle, if possible.",21,{"i":[{"n":"self"}],"o":{"g":["handle"],"n":"option"}}],[11,"new_tokio_handle","","Returns a reference to the new Tokio handle",20,{"i":[{"n":"self"}],"o":{"n":"handle"}}],[11,"remote","","Returns a reference to the underlying remote handle to the event loop.",20,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"spawn","","Spawns a new future on the event loop this handle is associated with.",20,null],[11,"spawn_send","","Spawns a new future onto the threadpool",20,null],[11,"spawn_fn","","Spawns a closure on this event loop.",20,null],[11,"id","","Return the ID of the represented Core",20,{"i":[{"n":"self"}],"o":{"n":"coreid"}}],[11,"new","","Creates a new interval which will fire at `dur` time into the future, and will repeat every `dur` interval after",24,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new_at","","Creates a new interval which will fire at the time specified by `at`, and then will repeat every `dur` interval after",24,{"i":[{"n":"instant"},{"n":"duration"},{"n":"handle"}],"o":{"g":["interval","error"],"n":"result"}}],[11,"new","","Creates a new readiness stream associated with the provided `loop_handle` and for the given `source`.",16,{"i":[{"n":"e"},{"n":"handle"}],"o":{"g":["pollevented","error"],"n":"result"}}],[11,"deregister","","Deregisters this source of events from the reactor core specified.",16,{"i":[{"n":"self"},{"n":"handle"}],"o":{"g":["error"],"n":"result"}}],[11,"poll_read","","Tests to see if this source is ready to be read from or not.",16,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_write","","Tests to see if this source is ready to be written to or not.",16,{"i":[{"n":"self"}],"o":{"n":"async"}}],[11,"poll_ready","","Test to see whether this source fulfills any condition listed in `mask` provided.",16,{"i":[{"n":"self"},{"n":"ready"}],"o":{"g":["ready"],"n":"async"}}],[11,"need_read","","Indicates to this source of events that the corresponding I/O object is no longer readable, but it needs to be.",16,null],[11,"need_write","","Indicates to this source of events that the corresponding I/O object is no longer writable, but it needs to be.",16,null],[11,"remote","","Returns a reference to the event loop handle that this readiness stream is associated with.",16,{"i":[{"n":"self"}],"o":{"n":"remote"}}],[11,"get_ref","","Returns a shared reference to the underlying I/O object this readiness stream is wrapping.",16,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"get_mut","","Returns a mutable reference to the underlying I/O object this readiness stream is wrapping.",16,{"i":[{"n":"self"}],"o":{"n":"e"}}],[11,"new","","Creates a new timeout which will fire at `dur` time into the future.",27,{"i":[{"n":"duration"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"new_at","","Creates a new timeout which will fire at the time specified by `at`.",27,{"i":[{"n":"instant"},{"n":"handle"}],"o":{"g":["timeout","error"],"n":"result"}}],[11,"reset","","Resets this timeout to an new timeout which will fire at the time specified by `at`.",27,null]],"paths":[[4,"DomainsValidation"],[8,"UdpCodec"],[8,"SessionStats"],[3,"Error"],[3,"RequestContext"],[4,"ErrorKind"],[4,"MiddlewareAction"],[3,"NoopExtractor"],[3,"Server"],[3,"CloseHandle"],[3,"ServerBuilder"],[8,"MetaExtractor"],[8,"RequestMiddleware"],[3,"Origin"],[3,"Host"],[3,"TcpStream"],[3,"PollEvented"],[3,"CoreId"],[3,"UdpSocket"],[3,"TcpListener"],[3,"Handle"],[3,"Remote"],[3,"Core"],[3,"UdpFramed"],[3,"Interval"],[3,"Incoming"],[3,"SendDgram"],[3,"Timeout"],[3,"RecvDgram"],[3,"TcpStreamNew"]]};
initSearch(searchIndex);
